# modified from: https://github.com/JustusAdam/language-haskell/blob/master/syntaxes/haskell.YAML-tmLanguage
fileTypes:
    - wy
keyEquivalent: ^~W
name: Wysk
patterns:
  - include: '#attribute'
  - include: '#comment_like'
  - include: '#numeric_literals'
  - include: '#string_literal'
  - include: '#char_literal'
  - match: '(?<!@|#)\}~'
    name: invalid
  - match: '(\()\s*(\))'
    name: constant.language.unit.wysk
    captures:
      '1': {name: punctuation.paren.wysk}
      '2': {name: punctuation.paren.wysk}
  - match: '(\()\s*,[\s,]*(\))'
    name: support.constant.tuple.wysk
    captures:
      '1': {name: punctuation.paren.wysk}
      '2': {name: punctuation.paren.wysk}
  - match: '(\[)\s*(\])'
    name: constant.language.empty-list.wysk
    captures:
      '1': {name: punctuation.bracket.wysk}
      '2': {name: punctuation.bracket.wysk}
  - begin: '(\b(?<!'')(module)|^(package))(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.module.wysk}
      '3': {name: keyword.other.signature.wysk}
    end: '(?=\b(?<!'')where\b(?!''))'
    name: meta.declaration.module.wysk
    patterns:
      - include: '#comment_like'
      - include: '#module_name'
      - include: '#module_exports'
      - match: '[a-z]+'
        name: invalid
  - include: '#ffi'
  - begin: '^(\s*)(class)(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.class.wysk}
    end: '\{'
    endCaptures:
      '0':
        patterns:
          - include: '#fun_decl'
    name: meta.declaration.class.wysk
    patterns:
      - include: '#comment_like'
      # - include: '#where'
      - include: '#type_signature'
  # GADT declaration
  # must find `where` keyword on the same line
  # (only way to distinguish between GADT and ADT)
  - begin: >-
      (?x)
        ^(\s*)(data|newtype)(?:\s+(impl))?\s+
        # Keep consuming characters until:
        ((?:(?!
        # the equals symbol or the start of a single-line comment, or
          (?:
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|~~[>|<|:~]?)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" or "with" keywords, or
        | (?:\b(?<!')(?:with)\b(?!'))
        # the start of a block comment.
        | {-
        #
        ).)*)
        (?=\b(?<!'')with\b(?!''))
    beginCaptures:
      '2': {name: keyword.other.$2.wysk}
      '3': {name: keyword.other.impl.wysk}
      '4':
        patterns:
          - include: '#type_signature'
    name: meta.declaration.$2.generalized.wysk
    end: |
      (?x) # Detect end of data declaration:
               # with clause
         (?=(?<!')\bwith\b(?!'))
               # Decreasing indentation
         |(?=\}|;)      # Explicit indentation
         |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
             \1\s+\S    # - more indented, or
           | \s*        # - starts with whitespace, followed by:
             (?: $      #   - the end of the line (i.e. empty line), or
             |\{-[^@]   #   - the start of a block comment, or
             |~~[>|<|:~]?       #   - the start of a single-line comment.
                (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                        # The double dash may not be followed by other operator characters
                        # (then it would be an operator, not a comment)
           )
    patterns:
      - include: '#comment_like'
      # Can't simply include 'where' pattern,
      # because it includes all of $self,
      # whereas we want something slightly different
      - begin: >-
          (?x)
            (?<!')\b(where)
            \s*(\{)(?!-)
        end: '\}'
        beginCaptures:
          '1': {name: keyword.other.where.wysk}
          '2': {name: punctuation.brace.wysk}
        endCaptures:
          '1': {name: punctuation.brace.wysk}
        patterns:
          - include: '#comment_like'
          - include: '#gadt_constructor'
          - match: ';'
            name: punctuation.semicolon.wysk
      - match: '\b(?<!'')(where)\b(?!'')'
        name: keyword.other.where.wysk
      - include: '#with'
      - include: '#gadt_constructor'
  - include: '#role_annotation'
  - name: 'meta.declaration.pattern.type.wysk'
    begin: '^(\s*)(pattern)\s+(.*?)\s+(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])'
    beginCaptures:
      '2': {name: keyword.other.pattern.wysk}
      '3':
        patterns:
          - include: '#comma'
          - include: '#data_constructor'
      '4': {name: keyword.operator.double-colon.wysk}
    end: |
      (?x) # Detect end of pattern type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{[^@]   #   - the start of a block comment, or
            |~~[>|<|:~]?       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '#type_signature'
  - name: 'meta.declaration.pattern.wysk'
    begin: '^\s*(pattern)\b(?!'')'
    captures:
      '1': {name: keyword.other.pattern.wysk}
    end: |
      (?x) # Detect end of pattern type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{[^@]   #   - the start of a block comment, or
            |~~[>|<|:~]?       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '$self'
  # ADT declaration (no "where" keyword on the same line)
  - begin: >-
      (?x)
        # Data declaration
        ^(\s*)(data|newtype)(?:\s+(family|impl))?\s+
        # Keep consuming characters until:
        (((?!
        # the equals symbol or the start of a single-line comment, or
          (?:
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|~~[>|<|:~]?)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" or "with" keywords, or
        | (?:\b(?<!')(?:with)\b(?!'))
        # the start of a block comment.
        | ~{
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.$2.wysk}
      '3': {name: keyword.other.$3.wysk}
      '4':
        patterns:
          - include: '#type_signature'
    name: meta.declaration.$2.algebraic.wysk
    end: >-
      (?x) # Detect end of data declaration:
           # Decreasing indentation
         (?=\}|;)      # Explicit indentation
         |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
             \1\s+\S    # - more indented, or
           | \s*        # - starts with whitespace, followed by:
             (?: $      #   - the end of the line (i.e. empty line), or
             |~\{   #   - the start of a block comment, or
             |~~[>|<|:~]?       #   - the start of a single-line comment.
                (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
           )
    patterns:
      - include: '#comment_like'
      - include: '#with'
      - include: '#forall'
      - include: '#adt_constructor'
      - include: '#data_context'
      - include: '#record_decl'
      - include: '#type_signature'
  - name: 'meta.declaration.type.family.wysk'
    begin: >-
      (?x)
        # Type family
        ^(\s*)(type)\s+(family)\b(?!')
        # Keep consuming characters until:
        (((?!
        # the equals symbol or the start of a single-line comment, or
          (?:
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|~~[>|<|:~]?)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the "where" keyword, or
        | \b(?<!')where\b(?!')
        # the start of a block comment.
        | ~{
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.type.wysk}
      '3': {name: keyword.other.family.wysk}
      '4':
        patterns:
          - include: "#comment_like"
          - include: '#where'
          - include: '#type_signature'
    end: |
      (?x) # Detect end of type family by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{[^@]   #   - the start of a block comment, or
            |~~[>|<|:~]?       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: "#comment_like"
      - include: '#where'
      - include: '#type_signature'
  - name: 'meta.declaration.type.wysk'
    begin: >-
      (?x)
        # Type declaration
        ^(\s*)(type)(?:\s+(impl))?\s+
        # Keep consuming characters until:
        (((?!
        # the equals symbol, the start of a single-line comment, or a type signature
          (?:
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:=|~~[>|<|:~]?|::|∷)
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
          )
        # the start of a block comment.
        | ~{
        #
        ).)*)
    beginCaptures:
      '2': {name: keyword.other.type.wysk}
      '3': {name: keyword.other.impl.wysk}
      '4':
        patterns:
          - include: '#type_signature'
    end: |
      (?x) # Detect end of type definition by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{   #   - the start of a block comment, or
            |~~[>|<|:~]?       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
          )
    patterns:
      - include: '#type_signature'
  - begin: '^(\s*)(impl)(\b(?!''))'
    beginCaptures:
      '2': {name: keyword.other.impl.wysk}
    end: '\{'
    endCaptures:
      '0':
        patterns:
          - include: '#fun_decl'
    name: meta.declaration.impl.wysk
    patterns:
      - include: '#comment_like'
      - include: '#type_signature'
  - begin: >-
      ^(\s*)(import)(\b(?!'))
    beginCaptures:
      '2': {name: keyword.other.import.wysk}
    end: |
      (?x) # Detect end of import
        # 'where' keyword
        (?=\b(?<!')(where)\b(?!'))
        # Decreasing indentation
        |(?=\}|;)      # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{   #   - the start of a block comment, or
            |~~[>|<|:~]       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    name: meta.import.wysk
    patterns:
      - include: '#comment_like'
      - include: '#where'
      - match: (qualified|hiding)
        captures:
          '1': {name: "keyword.other.$1.wysk"}
      - include: '#module_name'
      - include: '#qualified_name'
      - include: '#module_exports'
  - include: '#with'
  - include: '#layout_herald'
  - include: '#keyword'
  - match: '^\s*(infix[lr]?)\s+(.*)'
    captures:
      '1': {name: "keyword.other.fixity.$1.wysk"}
      '2':
        patterns:
          - include: '#comment_like'
          - include: '#integer_literals'
          - match: ':[\p{S}\p{P}&&[^(),;\[\]`{}_"'']]*'
            name: constant.other.operator.infix.wysk
          - include: "#infix_op"
    name: meta.fixity-declaration.wysk
  - include: '#start_type_signature'
  - include: '#overloaded_label'
  - include: '#type_application'
  - include: '#reserved_symbol'
  - include: '#fun_decl'
  - include: '#qualifier'
  - match: ':[\p{S}\p{P}&&[^(),;\[\]`{}_"'']]*'
    name: constant.other.operator.infix.wysk
  - include: '#data_constructor'
  - include: '#prefix_op'
  - include: '#infix_op'
  - begin: '(\()(#)\s'
    end: '(#)(\))'
    beginCaptures:
      '1': {name: punctuation.paren.wysk}
      '2': {name: keyword.operator.hash.wysk}
    endCaptures:
      '1': {name: keyword.operator.hash.wysk}
      '2': {name: punctuation.paren.wysk}
    patterns:
      - include: '#comma'
      - include: '$self'
  - begin: '(\()'
    end: '(\))'
    beginCaptures:
      '1': {name: punctuation.paren.wysk}
    endCaptures:
      '1': {name: punctuation.paren.wysk}
    patterns:
      - include: '#comma'
      - include: '$self'
  - include: '#quasi_quote'
  - begin: '(\[)'
    end: '(\])'
    beginCaptures:
      '1': {name: punctuation.bracket.wysk}
    endCaptures:
      '1': {name: punctuation.bracket.wysk}
    patterns:
      - include: '#comma'
      - include: '$self'
  - include: '#record'
repository:
  block_comment:
    applyEndPatternLast: 1
    begin: '~\{'
    captures:
      '0': {name: punctuation.definition.comment.wysk}
    end: '\}~'
    name: comment.block.wysk
    patterns:
      - include: '#block_comment'
  comments:
    patterns:
      - comment: Doc comments, first line begins with `~~> `
        begin: '^(\s*)(~~>)'
        beginCaptures:
          '2': {name: punctuation.whitespace.comment.leading.wysk}
        end: '(?=^(?!\1~~\|(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])))'
        name: comment.block.documentation.wysk
      - comment: Inline doc comments refer to the thing *above*
        begin: '(^[ \t]+)?(~~[\:\^])'
        beginCaptures:
          '1': {name: punctuation.whitespace.comment.leading.wysk}
        end: \n
        name: comment.line.documentation.wysk
      - comment: Embedded doc lines, `~~<FLAG>` `~~</>`
        begin: '~~\<\[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*\>'
        captures:
          '0': {name: punctuation.definition.comment.wysk}
        end: '~~\</\>'
        name: comment.block.documentation.wysk
      - comment: Non-doc line comments
        begin: >-
          (^[ \t]+)?(?=~~+\s*(?![\s{S}\p{P}&&[^(),;\[\]`{}_"']]))
        begineCaptures:
          '1': {name: punctuation.whitespace.comment.leading.wysk}
        end: '(?!\G)'
        patterns:
          - begin: '~~'
            beginCaptures:
              '0': {name: punctuation.definition.comment.wysk}
            end: \n
            name: comment.line.double-dash.wysk
      - {include: '#block_comment'}
      # # Doc comments: `~~>` OR `~~|` OR `~~<` OR `~~:`
      # - begin: '^(\s*)(~~>)'
      #   beginCaptures:
      #     '2': {name: punctuation.whitespace.comment.leading.wysk}
      #   end: '(?=^(?!\1~~[|:<](?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])))'
      #   name: comment.block.documentation.wysk
      # # Inline annotation (not necessarily at the start of a line)
      # - begin: '(^[ \t]+)?(~~:?)'
      #   beginCaptures:
      #     '1': {name: punctuation.whitespace.comment.leading.wysk}
      #   end: \n
      #   name: comment.line.documentation.wysk
      # # Doc block using ~{ }~ comments
      # - applyEndPatternLast: 1
      #   begin: '~\{'
      #   captures:
      #     '0': {name: punctuation.definition.comment.wysk}
      #   end: '\}~'
      #   name: comment.block.documentation.wysk
      #   patterns:
      #     - include: '#block_comment'
      # - begin: >-
      #     (^[ \t]*)?(?=~~\|[ \t]+(?![\p{S}\p{P}&&[^(),;\[\]`{}_"']]))
      #   beginCaptures:
      #     '1': {name: punctuation.whitespace.comment.leading.wysk}
      #   comment: 'Operators may begin with ''~~'' as long as they are not ''~~|'', ''~~|'', ''~~:'', or ''~~<'' nor entirely composed of ''~'' characters.'
      #   end: '(?!\G)'
      #   patterns:
      #     - begin: '~~'
      #       beginCaptures:
      #         '0': {name: punctuation.definition.comment.wysk}
      #       end: \n
      #       name: comment.line.double-dash.wysk
      # - begin: '~~\|'
      #   beginCaptures:
      #     '0': {name: punctuation.definition.comment.wysk}
      #   end: \n
      #   name: comment.line.double-dash.wysk
      # - {include: '#block_comment'}
  comment_like:
    patterns:
      - include: '#attribute'
      - include: '#comments'
  attribute:
    patterns:
      - comment: attributes
        name: meta.preprocessor.wysk
        begin: '(\#)(!)?(\[)'
        beginCaptures:
          '1':
              name: punctuation.attribute.wysk
          '2':
              name: keyword.operator.attribute.inner.wysk
          '3':
              name: punctuation.brackets.attribute.wysk
        end: '(?=\])'
        patterns:
          - include: '#comments'
          - match: >-
              (?xi)
              \b(?<!')(infix[lr]?)\b(?!')\s+(\d)?
            captures:
              '1': {name: keyword.other.fixity.$1.wysk}
              '2': {name: constant.numeric.floating.decimal.wysk}
      - comment: single attribute pragmas
        match: >-
          (?xi)
          \b(?<!')(inline|no(\_|\-)?inline|todo)\b(?!')
        name: keyword.other.preprocessor.wysk
      - comment: specialization pragma
        begin: >-
          (?xi)
            \b(?<!')(speciali(?:s|z)e)\b(?!')(.*)
        beginCaptures:
          '1': {name: keyword.other.preprocessor.wysk}
          '2':
            patterns:
              - include: '#type_signature'
        end: '(?=\])'
        patterns:
          - include: '$self'
  where:
    patterns:
      - begin: >-
          (?x)
            (?<!')\b(where)
            \s*(\{)(?!-)
        end: '(\})'
        beginCaptures:
          '1': {name: keyword.other.where.wysk}
          '2': {name: punctuation.brace.wysk}
        endCaptures:
          '1': {name: punctuation.brace.wysk}
        patterns:
          - include: '$self'
          - match: ';'
            name: punctuation.semicolon.wysk
      - match: '\b(?<!'')(where)\b(?!'')'
        name: keyword.other.where.wysk
  layout_herald:
    begin: >-
      (?x)
        (?:(?<!')\b(?:(def|fn|class|impl|where|let|do)|(of))|(match))
        \s*(?<!~)(\{)
    end: '(\})(?!~)'
    beginCaptures:
      '1': {name: keyword.other.$1.wysk}
      '2': {name: keyword.control.of.wysk}
      '3': {name: keyword.control.lambda-case.wysk}
      '4': {name: punctuation.brace.wysk}
    endCaptures:
      '1': {name: punctuation.brace.wysk}
    patterns:
      - include: '$self'
      - match: ';'
        name: punctuation.semicolon.wysk
  keyword:
    match: '\b(?<!'')(?:(where|let|in)|(do|if|then|else|case|of|match))\b(?!'')'
    captures:
      '1': {name: keyword.other.$1.wysk}
      '2': {name: keyword.control.$2.wysk}
  with:
    patterns:
      # with (start of line)
      - begin: '^(\s*)(with)\s+(?:(via|newtype)\s+)?'
        beginCaptures:
          '2': {name: keyword.other.with.wysk}
          '3': {name: keyword.other.with.strategy.$3.wysk}
        end: >-
          (?x) # Detect end of with statement
            # Decreasing indentation
             (?=\}|;)      # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |~\{[^@]   #   - the start of a block comment, or
                |~~+[>|:<^ ]       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        patterns:
          - include: '#comment_like'
          - match: '(?<!'')\b(impl)\b(?!'')'
            name: keyword.other.impl.wysk
          - match: '(?<!'')\b(via|newtype)\b(?!'')'
            captures:
              '1': {name: keyword.other.with.strategy.$1.wysk }
          - include: '#type_signature'
        name: meta.with.wysk
      # with (not start of line, parenthesised type)
      - begin: '(with)(?:\s+(newtype))?\s*(\()'
        beginCaptures:
          '1': {name: keyword.other.with.wysk}
          '2': {name: "keyword.other.with.strategy.$2.wysk"}
          '3': {name: punctuation.paren.wysk}
        end: '(\))'
        endCaptures:
          '1': {name: punctuation.paren.wysk}
        name: meta.with.wysk
        patterns:
          - include: '#type_signature'
      # with (not start of line, unparenthesised type)
      - match: |
          (?x)
            (with)(?:\s+(newtype))?\s+
              ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
              (\s+(via)\s+(.*)$)?
        captures:
          '1': {name: keyword.other.with.wysk}
          '2': {name: "keyword.other.with.strategy.$2.wysk"}
          '3': {patterns: [{include: '#type_signature'}]}
          '5': {name: keyword.other.with.strategy.via.wysk}
          '6': {patterns: [{include: '#type_signature'}]}
        name: meta.with.wysk
      - match: '(?<!'')\b(via)\b(?!'')'
        name: keyword.other.with.strategy.via.wysk
  prefix_op:
    patterns:
      - comment: >
          An operator cannot be composed entirely of '~' characters;
          instead, it should be matched as a comment.
        match: >-
          (?x)
            (\()\s*(?!(?:~~+[>|:<^]|\.\.)\))(\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))\s*(\))
        captures:
          '1': {name: punctuation.paren.wysk}
          '2': {name: entity.name.function.infix.wysk}
          '3': {name: punctuation.paren.wysk}
  infix_op:
    patterns:
      - match: >-
          (?x)
            ((?:(?<!'')('')?[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*\.)*)
              (\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))
        comment: >
          In case this regex seems overly general, note that Wysk permits
          the definition of new operators which can be nearly any string of
          punctuation characters, such as $%^&*.
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: entity.name.namespace.wysk}
          '3': {name: keyword.operator.infix.wysk}
      - match: >-
          (`)((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*\.)*)([\p{Ll}\p{Lu}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*)(`)
        captures:
          '1': {name: punctuation.backtick.wysk}
          '2': {name: entity.name.namespace.wysk}
          '3':
            patterns:
              - include: '#data_constructor'
          '4': {name: punctuation.backtick.wysk}
        comment: |
          In case this regex seems unusual for an infix operator, note that Wysk
          allows any ordinary function application (elem 4 [1..10]) to be rewritten
          as an infix expression (4 `elem` [1..10]).
        name: keyword.operator.function.infix.wysk
  qualified_name:
    begin: '\|'
    end: '\|'
    patterns:
      captures:
        '1' : {name: 'entity.name.namespace.wysk'}
  module_exports:
    begin: '\{'
    beginCaptures:
      '0': {name: punctuation.brace.wysk}
    end: '\}'
    endCaptures:
      '0': {name: punctuation.brace.wysk}
    applyEndPatternLast: 1
    name: meta.declaration.exports.wysk
    patterns:
      - include: '#comment_like'
      - match: '\b(?<!'')(module)\b(?!'')'
        captures:
          '1': {name: keyword.other.module.wysk}
      - include: '#comma'
      - include: '#export_constructs'
      - begin: '\{'
        beginCaptures:
          '0': {name: punctuation.brace.wysk}
        end: '\}'
        endCaptures:
          '0': {name: punctuation.brace.wysk}
        patterns:
          - include: '#comment_like'
          - include: '#record_wildcard'
          - match: >-
              (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
            name: constant.other.operator.prefix.wysk
          - include: '#export_constructs'
          - include: '#comma'
  export_constructs:
    patterns:
      - include: '#comment_like'
      - begin: '\b(?<!'')(pattern)\b(?!'')'
        beginCaptures:
          '1': {name: keyword.other.pattern.wysk}
        end: >-
         (?x)
            # Data constructor
            ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Prefix form of symbolic constructor
            | (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        endCaptures:
          '1': {name: constant.other.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: constant.other.operator.prefix.wysk}
          '4': {name: punctuation.paren.wysk}
        patterns:
          - include: '#comment_like'
      - begin: '\b(?<!'')(type)\b(?!'')'
        beginCaptures:
          '1': {name: keyword.other.type.wysk}
        end: >-
         (?x)
            # Type name
            ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Prefix form of type operator
            | (\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        endCaptures:
          '1': {name: storage.type.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: storage.type.operator.wysk}
          '4': {name: punctuation.paren.wysk}
        patterns:
          - include: '#comment_like'
      - include: '#record_wildcard'
      - include: '#reserved_symbol'
      - match: >-
          (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
        name: storage.type.operator.wysk
      - match: >-
         (?<!')\b[\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*
        name: entity.name.function.wysk
      - match: >-
          (?<!')\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*
        name: storage.type.wysk
      - include: '#prefix_op'
  comma:
    match: ','
    name: punctuation.separator.comma.wysk
  module_name:
    match: >-
      (?<conid>[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*(\.\g<conid>)?)
    name: entity.name.namespace.wysk
  data_context:
    match: |
      (?x)
        (.*)
        (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
        (=>|⇒)
        (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
    captures:
      '1':
         patterns:
            # Need to highlight the left of a context arrow => as a type,
            # but need to know when to stop: when we see a = or ::
            # that is not guarded by parentheses:
            #
            #   foo :: abc => def
            #         ^^^^^^^
            #
            #   foo :: forall (a :: T). C a => B
            #         ^^^^^^^^^^^^^^^^^^^^^^^^
            #
            - include: '#comment_like'
            - include: '#forall'
            - begin: '(?=''?\()'
              end: '(?=\))'
              patterns:
                - include: '#type_signature'
            - begin: '(?=''?\[)'
              end: '(?=\])'
              patterns:
                - include: '#type_signature'
            - match: >-
                (?x)
                  (\S*)\s*
                  (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                  (::|∷|=)
                  (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
              captures:
                '1':
                  patterns:
                    - include: '#comment_like'
                    - include: '#forall'
                    - include: '#record_decl_field'
                '2':
                  patterns:
                    - include: '#reserved_symbol'
                '3':
                  patterns:
                    - include: '#type_signature'
            - include: '#type_signature'
      '2': {name: keyword.operator.big-arrow.wysk}
  data_constructor:
    patterns:
      - match: >-
          \b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*(?![\.'\w])
        name: constant.other.wysk
      - match: >-
          (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
        name: constant.other.operator.wysk
  qualifier:
    match: >-
      \b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.
    name: entity.name.namespace.wysk
  record_decl:
    begin: '(?<!~)({)'
    beginCaptures:
      '1': {name: punctuation.brace.wysk}
    end: '(})(?!~)'
    endCaptures:
      '1': {name: punctuation.brace.wysk}
    name: meta.record.definition.wysk
    patterns:
      - include: '#comment_like'
      - include: '#record_decl_field'
  record:
    begin: '(?<!~)({)'
    beginCaptures:
      '1': {name: punctuation.brace.wysk}
    end: '(})(?!~)'
    endCaptures:
      '1': {name: punctuation.brace.wysk}
    name: meta.record.wysk
    patterns:
      - include: '#comment_like'
      - include: '#record_field'
  record_decl_field:
    begin: |
      (?x)
        (?:([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
          |(\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
        )
    end: '(,)|(?=})'
    beginCaptures:
      '1': {name: variable.other.member.definition.wysk}
      '2': {name: punctuation.paren.wysk}
      '3': {name: variable.other.member.definition.wysk}
      '4': {name: punctuation.paren.wysk}
    endCaptures:
      '1': {name: punctuation.comma.wysk}
    patterns:
      - include: '#comment_like'
      - include: '#comma'
      - include: '#double_colon'
      - include: '#type_signature'
      - include: '#record_decl_field'
  record_wildcard:
    match: >-
      (?x)
        (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
        (\.\.)
        (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
    captures:
      '1': {name: variable.other.member.wildcard.wysk}
  record_field:
    patterns:
      - begin: |
          (?x)
            (?:([\p{Ll}\p{Lu}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\.']*)
              |(\()\s*([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\))
            )
        end: '(,)|(?=})'
        beginCaptures:
          '1':
            name: variable.other.member.wysk
            patterns:
              - include: '#qualifier'
          '2': {name: punctuation.paren.wysk}
          '3': {name: variable.other.member.wysk}
          '4': {name: punctuation.paren.wysk}
        endCaptures:
          '1': {name: punctuation.comma.wysk}
        patterns:
          - include: '#comment_like'
          - include: '#comma'
          - include: '$self'
      - include: '#record_wildcard'
  role_annotation:
    patterns:
      - begin: '^(\s*)(type)\s+(role)\b(?!'')'
        beginCaptures:
          '2': {name: keyword.other.type.wysk}
          '3': {name: keyword.other.role.wysk}
        end: >-
          (?x) # Detect end of block by decreasing indentation:
            (?=\}|;)       # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |\{-[^@]   #   - the start of a block comment, or
                |~~[>|:<^]       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        name: meta.role-annotation.wysk
        patterns:
          - include: '#comment_like'
          - include: '#type_constructor'
          - match: '\b(?<!'')(nominal|representational|phantom)\b(?!'')'
            captures:
              '1': {name: "keyword.other.role.$1.wysk"}
  fun_decl:
    patterns:
      - begin: |
          (?x)^(\s*)(fn)\s+
            (?<fn>
              (?:
                [\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\#*
              | \(\s*
                  (?!~~[>|:<^]\))
                  [\p{S}\p{P}&&[^(),:;\[\]`{}_"']]
                  [\p{S}\p{P}&&[^(),;\[\]`{}_"']]*
                \s*\)
              )
              (?:\s*,\s*\g<fn>)?
            )
            \s*(?<![\p{S}\p{P}&&[^\),;\]`}_"']])(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"']])
        beginCaptures:
          '2': {name: keyword.other.$2.wysk}
          '3':
            name: entity.name.function.wysk
            patterns:
              - include: '#reserved_symbol'
              - include: '#prefix_op'
          '4': {name: keyword.operator.double-colon.wysk}
        name: meta.function.type-declaration.wysk
        patterns:
          - include: '#type_signature'
        end: |
          (?x)
            # End of type annotation:
              # To the left of a reserved symbolic keyword such as = or <-
            (?=
                # non-symbolic character
                (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                # symbolic keyword except (->)
                ((<-|←)|(=)|(-<|↢)|(-<<|⤛))
                # non-symbolic character
                ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
            )
            # Decreasing indentation:
            |(?=^\s*\|)
            |(?=\}|;)      # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |~\{[^@]   #   - the start of a block comment, or
                |~~[>|:<^]       #   - the start of a single-line comment.
                  (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                          # The double dash may not be followed by other operator characters
                          # (then it would be an operator, not a comment)
              )
      - begin: |
          (?x)^(\s*)(fn)\s+
            (?<fn>
              (?:
                [\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\#*
              | \(\s*
                  (?!~~[>|:<^]\))
                  [\p{S}\p{P}&&[^(),:;\[\]`{}_"']]
                  [\p{S}\p{P}&&[^(),;\[\]`{}_"']]*
                \s*\)
              )
              (?:\s*,\s*\g<fn>)?
            )
            \s*(?<![\p{S}\p{P}&&[^\),;\]`}_"']])(\|)(?![\p{S}\p{P}&&[^\(,;\[`{_"']])
        beginCaptures:
          '2': {name: keyword.other.$2.wysk}
          '3':
            name: entity.name.function.wysk
            patterns:
              - include: '#reserved_symbol'
              - include: '#prefix_op'
          '4': {name: keyword.operator.pipe.wysk}
        name: meta.function.type-declaration.wysk
        patterns:
          - include: '#type_signature'
  adt_constructor:
    patterns:
      - include: '#comment_like'
      - begin: >-
          (?x)
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
            (?:(=|\|))
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
        beginCaptures:
          '1': {name: keyword.operator.eq.wysk}
          '2': {name: keyword.operator.pipe.wysk}
        end: >-
          (?x)
            (?: # Infix data constructor
              # First argument
              (?:
              # Simple type
                (?<!')\b((?:[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\.])+)
              # Type inside balanced parentheses
              | ('? # Optional promotion tick
                  (?<paren>
                    \(          # Opening parenthesis
                    (?:
                      [^\(\)]*  # Match non-parentheses
                    | \g<paren> # or recurse into further depth
                    )*
                    \)          # Closing parenthesis
                  )
                )
              # Type inside balanced brackets
              | ('? # Optional promotion tick
                  (?<brac>
                    \[          # Opening bracket
                    (?:
                      [^\[\]]*  # Match non-brackets
                    | \g<brac>  # or recurse into further depth
                    )*
                    \]          # Closing bracket
                  )
                )
              )
              # Then either
              \s*
                # - a symbolic infix constructor, or
              (?:(?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)
                # - an alphabetic infix constructor
              | (`)([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)(`)
              )
            ) # Otherwise, prefix data constructor, either:
            | # - an alphabetic data constructor e.g. "Cons_123"
              (?:(?<!')\b([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*))
            | # - a symbolic (prefix) data constructor
              (\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
            | # Otherwise, try to fail early to avoid excessive backtracking (https://github.com/JustusAdam/language-haskell/issues/161)
                # Fail when detecting a lowercase identifier and then something not starting with a tick or colon
                (?=\b(?<!')(?!(?:forall|with)\s)[\p{Ll}_]\S+\s+[^`:])
                # Fail when seeing another equal signs or pipe symbol
               |(?=
                  (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']]) # non-symbol
                  (?:=|\|)
                  (?![\p{S}\p{P}&&[^(),;\[\]`{}_"']])  # non-symbol
                )
        endCaptures:
          '1':
            patterns:
             - include: '#type_signature'
          '2':
            patterns:
              - include: '#type_signature'
          '4':
            patterns:
              - include: '#type_signature'
          '6': {name: constant.other.operator.infix.wysk}
          '7': {name: punctuation.backtick.wysk}
          '8': {name: constant.other.infix.wysk}
          '9': {name: punctuation.backtick.wysk}
          '10': {name: constant.other.wysk}
          '11': {name: punctuation.paren.wysk}
          '12': {name: constant.other.operator.prefix.wysk}
          '13': {name: punctuation.paren.wysk}
        patterns:
          - include: '#comment_like'
          - include: '#with'
          - include: '#record_decl'
          - include: '#forall'
          - include: '#data_context'
          - include: '#type_signature'
  gadt_constructor:
    patterns:
      # GADT constructor on start of line
      - begin: >-
          (?x)
             ^(\s*)
                (?:
                  (\b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
                |(\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))
                )
        beginCaptures:
          '2': {name: constant.other.wysk}
          '3': {name: punctuation.paren.wysk}
          '4': {name: constant.other.operator.prefix.wysk}
          '5': {name: punctuation.paren.wysk}
        end: |
          (?x)
            # GADT constructor ends
            (?=\b(?<!'')with\b(?!'))
                  # Decreasing indentation
            |(?=\}|;)      # Explicit indentation
            |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                \1\s+\S    # - more indented, or
              | \s*        # - starts with whitespace, followed by:
                (?: $      #   - the end of the line (i.e. empty line), or
                |~\{[^@]   #   - the start of a block comment, or
                |~~[>|:<^]       #   - the start of a single-line comment.
                   (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                           # The double dash may not be followed by other operator characters
                           # (then it would be an operator, not a comment)
              )
        patterns:
          - include: '#comment_like'
          - include: '#with'
          - include: '#double_colon'
          - include: '#record_decl'
          - include: '#type_signature'
      # Remaining case: GADT constructor not on start of line
      - begin: >-
          (?x)
            (\b(?<!')[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}]*) # named constructor
           |(\()\s*(:[\p{S}\p{P}&&[^(),;\[\]`{}_"']]*)\s*(\))    # prefix operator
        beginCaptures:
          '1': {name: constant.other.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: constant.other.operator.prefix.wysk}
          '4': {name: punctuation.paren.wysk}
        end: '(?=;|\}|$)'
        patterns:
          - include: '#comment_like'
          - include: '#with'
          - include: '#double_colon'
          - include: '#record_decl'
          - include: '#type_signature'
  type_application:
    patterns:
      - begin: '(?<=[\s,;\[\]{}"])(@)('')?(\()'
        beginCaptures:
          '1': {name: keyword.operator.prefix.at.wysk}
          '2': {name: keyword.operator.promotion.wysk}
          '3': {name: punctuation.paren.wysk}
        end: '\)'
        endCaptures:
          '0': {name: punctuation.paren.wysk}
        name: meta.type-application.wysk
        patterns:
          - include: '#type_signature'
      - begin: '(?<=[\s,;\[\]{}"])(@)('')?(\[)'
        beginCaptures:
          '1': {name: keyword.operator.prefix.at.wysk}
          '2': {name: keyword.operator.promotion.wysk}
          '3': {name: punctuation.bracket.wysk}
        end: '\]'
        name: meta.type-application.wysk
        endCaptures:
          '0': {name: punctuation.bracket.wysk}
        patterns:
          - include: '#type_signature'
      - begin: '(?<=[\s,;\[\]{}"])(@)(?=\")'
        beginCaptures:
          '1': {name: keyword.operator.prefix.at.wysk}
        end: '(?<=\")'
        name: meta.type-application.wysk
        patterns:
          - include: '#string_literal'
      - begin: '(?<=[\s,;\[\]{}"])(@)(?=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}''])'
        beginCaptures:
          '1': {name: keyword.operator.prefix.at.wysk}
        end: '(?![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}''])'
        name: meta.type-application.wysk
        patterns:
          - include: '#type_signature'
  type_signature:
    patterns:
      - include: '#comment_like'
      - match: '('')?(\()\s*(\))'
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: punctuation.paren.wysk}
        name: support.constant.unit.wysk
      - match: '(\()(#)\s*(#)(\))'
        name: support.constant.unit.unboxed.wysk
        captures:
          '1': {name: punctuation.paren.wysk}
          '2': {name: keyword.operator.hash.wysk}
          '3': {name: keyword.operator.hash.wysk}
          '4': {name: punctuation.paren.wysk}
      - match: '('')?(\()\s*,[\s,]*(\))'
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: punctuation.paren.wysk}
        name: support.constant.tuple.wysk
      - match: '(\()(#)\s*(#)(\))'
        name: support.constant.unit.unboxed.wysk
        captures:
          '1': {name: punctuation.paren.wysk}
          '2': {name: keyword.operator.hash.wysk}
          '3': {name: keyword.operator.hash.wysk}
          '4': {name: punctuation.paren.wysk}
      - match: '(\()(#)\s*,[\s,]*(#)(\))'
        captures:
          '1': {name: punctuation.paren.wysk}
          '2': {name: keyword.operator.hash.wysk}
          '3': {name: keyword.operator.hash.wysk}
          '4': {name: punctuation.paren.wysk}
        name: support.constant.tuple.unboxed.wysk
      - match: '('')?(\[)\s*(\])'
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.bracket.wysk}
          '3': {name: punctuation.bracket.wysk}
        name: support.constant.empty-list.wysk
      - include: '#integer_literals'
      - match: '(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])'
        name: keyword.operator.double-colon.wysk
      - include: '#forall'
      - match: '=>|⇒'
        name: keyword.operator.big-arrow.wysk
      - include: '#string_literal'
      - match: '''[^'']'''
        name: invalid
      - include: '#type_application'
      - include: '#reserved_symbol'
      - include: '#type_operator'
      - include: '#type_constructor'
      - begin: '(\()(#)'
        end: '(#)(\))'
        beginCaptures:
          '1': {name: punctuation.paren.wysk}
          '2': {name: keyword.operator.hash.wysk}
        endCaptures:
          '1': {name: keyword.operator.hash.wysk}
          '2': {name: punctuation.paren.wysk}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - begin: '('')?(\()'
        end: '(\))'
        beginCaptures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.paren.wysk}
        endCaptures:
          '1': {name: punctuation.paren.wysk}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - begin: '('')?(\[)'
        end: '(\])'
        beginCaptures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.bracket.wysk}
        endCaptures:
          '1': {name: punctuation.bracket.wysk}
        patterns:
          - include: '#comma'
          - include: '#type_signature'
      - include: '#type_variable'
  double_colon:
    match: '\s*(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])\s*'
    captures:
      '1': {name: keyword.operator.double-colon.wysk}
  start_type_signature:
    patterns:
      - begin: '^(\s*)(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"'']])\s*'
        beginCaptures:
          '2': {name: keyword.operator.double-colon.wysk}
        end: >-
          (?x)
            # End type annotation when seeing one of:
            (?=
              \#?\)                             # closing parenthesis
              |\]                               # closing bracket
              |\}
              |,                                # comma
              |(?<!')\b(def|fn|in|then|else|of)\b(?!') # keyword
              |                                 # symbolic keyword except (->)
                (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                (?:
                   (\\|λ)
                  |(<-|←)
                  |(=)
                  |(\|)
                  |(-<|↢)
                  |(-<<|⤛)
                )
                ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
              |\]                             # End of annotation block (LiquidWysk or pragma)
              # Decreasing indentation:
              |(?=^\s*\|)
              | (?=\}|;)     # Explicit indentation
              |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
                  \1\s*\S    # - equally indented, or
                | \s*        # - starts with whitespace, followed by:
                  (?: $      #   - the end of the line (i.e. empty line), or
                  |~\{[^@]   #   - the start of a block comment, or
                  |~~[>|:<^]   #  - the start of a single-line comment.
                     (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                             # The double dash may not be followed by other operator characters
                             # (then it would be an operator, not a comment)
                )
            )
        patterns:
          - include: '#type_signature'
        name: meta.type-declaration.wysk
      - begin: '(?<![\p{S}\p{P}&&[^\(,;\[`{_"'']])(::|∷)(?![\p{S}\p{P}&&[^\(,;\[`{_"'']])'
        beginCaptures:
          '1': {name: keyword.operator.double-colon.wysk}
        end: >-
          (?x)
            # End type annotation when seeing one of:
            (?=
              \#?\)                             # closing parenthesis
              |\]                               # closing bracket
              |\}
              |,                                # comma
              |\b(?<!')(def|fn|in|if|then|else|of)\b(?!') # keyword
              |                                 # symbolic keyword except (->)
                (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"']])
                (?:
                   (\\|λ)
                  |(<-|←)
                  |(=)
                  |(=>)
                  |(\|)
                  |(-<|↢)
                  |(-<<|⤛)
                )
                ([(),;\[\]`{}_"']|[^\p{S}\p{P}])
              # Indentation
              |(?=^\s*\|)
              |(?=\}|;)      # Explicit indentation
              |$             # End of line
            )
        patterns:
          - include: '#type_signature'
  type_variable:
    match: '\b(?<!'')(?!(?:forall|with)\b(?!''))[\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*'
    name: variable.other.generic-type.wysk
  type_constructor:
    patterns:
      # Type starting with a capital letter (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Optional qualified name
              ((?:\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type constructor proper
              (\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: entity.name.namespace.wysk}
          '3': {name: storage.type.wysk}
      # Prefix form of a type operator (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Opening parenthesis
              (\()\s*
            # Optional qualified name
              ((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type operator proper
              ([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)
            # Closing parenthesis
              \s*(\))
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.paren.wysk}
          '3': {name: entity.name.namespace.wysk}
          '4': {name: storage.type.operator.wysk }
          '5': {name: punctuation.paren.wysk}
  overloaded_label:
    patterns:
      # See https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0170-unrestricted-overloadedlabels.rst
      - match: >-
          (?x)
            (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^(,;\[`{]]) # Disallow closing characters
            (\#)
              (?:
              # String
              ("(?:\\"|[^"])*")
              # Sequence of allowed label identifiers
              |[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\.]+
              )
        captures:
          '1': {name: keyword.operator.prefix.hash.wysk}
          '2':
            patterns:
              - include: '#string_literal'
        name: entity.name.label.wysk
  reserved_symbol:
    patterns:
      # Fully reserved symbols,
      # not including '::' (special treatment as it starts type highlighting),
      # nor '∀' (highlights subsequent dot for quantification).
      - match: >-
          (?x)
            (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
            (?:
               (\.\.)
              |(:)
              |(=)
              |(\\)     # λ not reserved as it is a letter
              |(\|)
              |(<-|←)
              |(->|→)
              |(-<|↢)
              |(-<<|⤛)
              |(>-|⤚)
              |(>>-|⤜)
            )
            (?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
        captures:
          '1': {name: keyword.operator.double-dot.wysk}
          '2': {name: keyword.operator.colon.wysk}
          '3': {name: keyword.operator.eq.wysk}
          '4': {name: keyword.operator.lambda.wysk}
          '5': {name: keyword.operator.pipe.wysk}
          '6': {name: keyword.operator.arrow.left.wysk}
          '7': {name: keyword.operator.arrow.wysk}
          '8': {name: keyword.operator.arrow.left.tail.wysk}
          '9': {name: keyword.operator.arrow.left.tail.double.wysk}
          '10': {name: keyword.operator.arrow.tail.wysk}
          '11': {name: keyword.operator.arrow.tail.double.wysk}
      # Reserved postfix symbol: '#'
      # This allows users to specify highlighting of '#' dependent on theme,
      # as we are unfortunately unable to make a decision based on enabled extensions.
      - match: >-
          (?x)
            (?<=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^\#,;\[`{]]) # Require closing characters
            (\#+)
            (?![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^),;\]`}]])   # Disallow opening character
        captures:
          '1': {name: keyword.operator.postfix.hash.wysk}
      # Reserved tight infix symbol: '@'
      - match: >-
          (?x)
            (?<=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\)\}\]]) # Require closing characters
            (@)
            (?=[\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'\(\[\{]) # Require opening character
        captures:
          '1': {name: keyword.operator.infix.tight.at.wysk}
      # Reserved prefix symbols,
      # not including '@' (special treatment, as a type application starts type highlighting).
      - match: >-
          (?x)
            (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}\p{S}\p{P}&&[^(,;\[`{]])  # Disallow closing characters
            (?:(~)|(!)|(-)|(\$\$)|(\$)|(%))
            (?=[\p{Ll}_'\p{Lu}\p{Lt}\p{Nd}\(\{\[]) # Require opening character (non operator symbol)
        captures:
          '1': {name: keyword.operator.prefix.tilde.wysk}
          '2': {name: keyword.operator.prefix.bang.wysk}
          '3': {name: keyword.operator.prefix.minus.wysk}
          '4': {name: keyword.operator.prefix.double-dollar.wysk}
          '5': {name: keyword.operator.prefix.dollar.wysk}
          '6': {name: keyword.operator.prefix.modifier.wysk}
  type_operator:
    patterns:
      # Symbolic type operator (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (?:(?<!')('))?
            # Optional qualified name
              ((?:\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type operator proper
              (?![#@]?-})(\#+|[\p{S}\p{P}&&[^(),;\[\]`{}_"']]+(?<!\#))
              #((?:[\p{S}\p{P}&&[^(),;\[\]`{}_"']&&[^#@]]|[@#](?!-}))+)
        captures:
          '1': {name: keyword.operator.promotion.wysk }
          '2': {name: entity.name.namespace.wysk }
          '3': {name: storage.type.operator.infix.wysk }
      # Infix form of alphanumeric type (optional promotion & qualification)
      - match: >-
          (?x)
            # Optional promotion tick
              (')?
            # Opening backtick
              (\`)
            # Optional qualified name
              ((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*)
            # Type constructor proper
              ([\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)
            # Closing backtick
              (`)
        captures:
          '1': {name: keyword.operator.promotion.wysk}
          '2': {name: punctuation.backtick.wysk}
          '3': {name: entity.name.namespace.wysk}
          '4': {name: storage.type.infix.wysk}
          '5': {name: punctuation.backtick.wysk}
  forall:
    begin: >-
      (?x)
        # Alphabetic forall
        (?:
        \b(?<!')
        (forall)
        \b(?!')
        )
        |
        # Symbolic forall
        (?:
        # Not preceded by a symbol except reserved symbols
        (?<![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
        (∀)
        # Not followed by a symbol except reserved symbols
        (?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']])
        )
    end: '(\.)|(->|→)'
    beginCaptures:
      '1': {name: keyword.other.forall.wysk}
      '2': {name: keyword.other.forall.wysk}
    endCaptures:
      '1': {name: keyword.operator.period.wysk}
      '2': {name: keyword.operator.arrow.wysk}
    patterns:
      - include: '#comment_like'
      - include: '#type_variable'
      - include: '#type_signature'
  string_literal:
    begin: '"'
    beginCaptures:
      '0': {name: punctuation.definition.string.begin.wysk}
    end: '"'
    endCaptures:
      '0': {name: punctuation.definition.string.end.wysk}
    name: string.quoted.double.wysk
    patterns:
      - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
        name: constant.character.escape.wysk
      - match: '\\o[0-7]+|\\x[0-9A-Fa-f]+|\\[0-9]+'
        name: constant.character.escape.octal.wysk
      - match: '\\\^[A-Z@\[\]\\\^_]'
        name: constant.character.escape.control.wysk
      - begin: \\\s
        beginCaptures:
          '0': {name: constant.character.escape.begin.wysk}
        end: \\
        endCaptures:
          '0': {name: constant.character.escape.end.wysk}
        patterns:
          - match: \S+
            name: invalid.illegal.character-not-allowed-here.wysk
  char_literal:
    captures:
      '1': {name: punctuation.definition.string.begin.wysk}
      '2': {name: constant.character.escape.wysk}
      '3': {name: constant.character.escape.octal.wysk}
      '4': {name: constant.character.escape.hexadecimal.wysk}
      '5': {name: constant.character.escape.control.wysk}
      '6': {name: punctuation.definition.string.end.wysk}
    match: |
      (?x)
        (?<![\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'])
        (')
        (?:
          [\ -\[\]-~]                         # Basic Char
        | (\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE
             |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS
             |US|SP|DEL|[abfnrtv\\\"'\\&]))   # Escapes
        | (\\o[0-7]+)                         # Octal Escapes
        | (\\x[0-9A-Fa-f]+)                   # Hexadecimal Escapes
        | (\\\^[A-Z@\[\]\\\^_])                 # Control Chars
        )
        (')
    name: string.quoted.single.wysk
  float_literals:
    comment: 'Floats are decimal or hexadecimal'
    match: >-
      (?x)
        \b(?<!')
        (?:  # Decimal
          ([0-9][_0-9]*\.[0-9][_0-9]*(?:[eE][-+]?[0-9][_0-9]*)?
          |[0-9][_0-9]*[eE][-+]?[0-9][_0-9]*
          )
        |    # Hexadecimal
          (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*\.[0-9a-fA-F][_0-9a-fA-F]*(?:[pP][-+]?[0-9][_0-9]*)?
          |0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*[pP][-+]?[0-9][_0-9]*
          )
        )\b(?!')
    captures:
      '1': {name: constant.numeric.floating.decimal.wysk}
      '2': {name: constant.numeric.floating.hexadecimal.wysk}
  integer_literals:
    match: >-
      (?x)
        \b(?<!')
        (?:
          ([0-9][_0-9]*)                    # Decimal integer
        | (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*) # Hexadecimal integer
        | (0[oO]_*[0-7][_0-7]*)             # Octal integer
        | (0[bB]_*[01][_01]*)               # Binary integer
        )
        \b(?!')
    captures:
      '1': {name: constant.numeric.integral.decimal.wysk}
      '2': {name: constant.numeric.integral.hexadecimal.wysk}
      '3': {name: constant.numeric.integral.octal.wysk}
      '4': {name: constant.numeric.integral.binary.wysk}
  numeric_literals:
    patterns:
      # Need to try to parse floating literals first,
      # to avoid having leftover dots.
      - include: '#float_literals'
      - include: '#integer_literals'
  ffi:
    begin: '^(\s*)(extern)\s+(import|export)\s+'
    beginCaptures:
      '2': {name: keyword.other.extern.wysk}
      '3': {name: "keyword.other.$3.wysk"}
    name: meta.$3.extern.wysk
    end: |
      (?x) # Detect end of FFI block by decreasing indentation:
        (?=\}|;)       # Explicit indentation
        |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:
            \1\s+\S    # - more indented, or
          | \s*        # - starts with whitespace, followed by:
            (?: $      #   - the end of the line (i.e. empty line), or
            |~\{[^@]   #   - the start of a block comment, or
            |~~[>|:<^]       #   - the start of a single-line comment.
               (?![\p{S}\p{P}&&[^(),;\[\]{}`_"']]).*$) # non-symbol
                       # The double dash may not be followed by other operator characters
                       # (then it would be an operator, not a comment)
          )
    patterns:
      - include: '#comment_like'
      - match: '\b(?<!'')(ccall|rustfn)\s+'
        captures:
          '1': {name: "keyword.other.calling-convention.$1.wysk"}
      - begin: '(?=")|(?=\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*)\b(?!''))'
        end: '(?=(::|∷)(?![\p{S}\p{P}&&[^(),;\[\]`{}_"'']]))'
        patterns:
          # safe/unsafe/interruptible keywords,
          # but we must take care to still allow a function named "safe" without such a keyword
          # for instance:
          #
          # extern import ccall safe foo :: ...
          #                      ^^^^ keyword
          #
          # extern import ccall safe :: ...
          #                      ^^^^ not a keyword
          - include: '#comment_like'
          - match: |
              (?x)
                \b(?<!')(safe|unsafe)\b(?!')
                \s*
                ("(?:\\"|[^"])*")?
                \s*
                (?:
                  (?:\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)\b(?!'))
                 |(?:\(\s*(?!~~[>|:<^]\))([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*\))
                )
            captures:
              '1': {name: "keyword.other.safety.$1.wysk"}
              '2':
                name: entity.name.extern.wysk
                patterns:
                  - include: '#string_literal'
              '3': {name: entity.name.function.wysk}
              '4': {name: entity.name.function.infix.wysk}
          # Assume that if there is no function name on this line, it will appear on the next line
          - match: |
              (?x)
                \b(?<!')(safe|unsafe)\b(?!')
                \s*
                ("(?:\\"|[^"])*")?
                \s*$
            captures:
              '1': {name: "keyword.other.safety.$1.wysk"}
              '2':
                name: entity.name.extern.wysk
                patterns:
                  - include: '#string_literal'
          - match: >-
              (?x)
                "(?:\\"|[^"])*"
            captures:
              '0':
                name: entity.name.extern.wysk
                patterns:
                  - include: '#string_literal'
          - match: |
              (?x)
                 (?:\b(?<!'')([\p{Ll}_][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*)\b(?!'))
                |(?:(\()\s*(?!~~[>|:<^]\))([\p{S}\p{P}&&[^(),;\[\]`{}_"']]+)\s*(\)))
            captures:
              '1': {name: entity.name.function.wysk}
              '2': {name: punctuation.paren.wysk}
              '3': {name: entity.name.function.infix.wysk}
              '4': {name: punctuation.paren.wysk}
      - include: '#double_colon'
      - include: '#type_signature'
  inline_phase:
    begin: '\['
    beginCaptures:
      '0': {name: punctuation.bracket.wysk}
    end: '\]'
    endCaptures:
      '0': {name: punctuation.bracket.wysk}
    name: meta.inlining-phase.wysk
    patterns:
      - match: '~'
        name: punctuation.tilde.wysk
      - include: '#integer_literals'
      - match: '\w*'
        name: invalid
  quasi_quote:
    patterns:
      - begin: >-
          (?x)
            (\[)
            (e|d|p)?
            (\|(?:\|(?!\]))?)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.wysk}
          '2': {name: entity.name.quasi-quoter.wysk}
          '3': {name: keyword.operator.quasi-quotation.begin.wysk}
        end: '\3\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.wysk}
        name: meta.quasi-quotation.wysk
        patterns:
          - include: '$self'
      - begin: >-
          (?x)
            (\[)
            (t)
            (\|(?:\|(?!\]))?)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.wysk}
          '2': {name: entity.name.quasi-quoter.wysk}
          '3': {name: keyword.operator.quasi-quotation.begin.wysk}
        end: '\3\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.wysk}
        name: meta.quasi-quotation.wysk
        patterns:
          - include: '#type_signature'
      - begin: >-
          (?x)
            (\[)
            (?:(\$\$)|(\$))?
            (?!'\|')                                             # Don't parse ['|'...] as a quasi quotation
            ((?:[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}']*\.)*) # Optional qualifier
            ((?:[^\s\p{S}\p{P}]|['_])*)                          # Quasi-quoter
            (\|)
        beginCaptures:
          '1': {name: keyword.operator.quasi-quotation.begin.wysk}
          '2': {name: keyword.operator.prefix.double-dollar.wysk}
          '3': {name: keyword.operator.prefix.dollar.wysk}
          '4': {name: entity.name.namespace.wysk}
          '5': {name: entity.name.quasi-quoter.wysk}
          '6': {name: keyword.operator.quasi-quotation.begin.wysk}
        end: '\|\]'
        endCaptures:
          '0': {name: keyword.operator.quasi-quotation.end.wysk}
        name: "meta.quasi-quotation.wysk meta.embedded.block.$5"
scopeName: source.wysk