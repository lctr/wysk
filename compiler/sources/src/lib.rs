//! This library deals with source files and exposes an API used to facilitate
//! bookkeeping of file-related sources.
//!
//! # General structure
//! A text file undergoes a series of transformations throughout the compiler's
//! workflow.
//!
//! * file path - the actual filepath used to locate the file
//! * file location - metadata regarding parent directory
//! * file name - shortened form of file path not including extension
//! * file
//! * file contents - variations in representing the contents of a file
//!     * Interning
//!         - lexicon: stored string slices associated with textual data
//!             * user action: retrieve symbol corresponding to a string slice
//!         - abacus: stored intermediary representations of textual data
//!             * user action: retrieve X corresponding to data D from a string
//!               slice
//!     * Lexing
//!         - character stream: chars generated from reading a file
//!             * user action: iterate over characters
//!         - token stream: lexemes generated from lexing the character stream
//!             * user action: iterate over tokens
//!     * Parsing
//!         - program: nodes generated from parsing the token stream
//!             * module parser
//!             * user action: iterate over declarations
//!     * Checking
//!         - interface: metadata generated from analyzing the program
//!             * tree: simplified AST generated from translating and reducing
//!               program to STG(? or core-like)-friendly intermediary
//!               representation
//!             * names: unique identifiers generated from renaming program data
//!             * types: type information generated by unifying inferred types
//!               with resolved program-defined types.
//!             * relations: metadata regarding dependencies within the program
//!               as well as with external data inported from another program
//!             * reports: miscellaneous information gathered throughout
//!               semantic analysis phases
//!
//!
//! FUNCTIONS
//! Principal actions:
//! * Compile project
//! * Run project
//! * Check project
//! * Interact (REPL)
//!
//! Compilation
//! - file based:
//!     read file -> file_string => read string characters -> lexemes
//!     read lexemes -> parse declarations -> defns
//!     read defns -> apply fixities -> modified_defns
//!     read defns -> simplify -> modified_defns + names
//!     read defns -> infer types -> modified_defns + type_info
//!     read defns -> resolve unified -> modified_dfns + resolution
//! - module based:
//!     read manifest -> filepaths -> parse files ->
//! - interaction based

use std::{
    fs::File,
    path::{self, Path, PathBuf},
};

use wy_common::Deque;
use wy_failure::Failure;

wy_common::newtype! { u32 in Fid | Show Usize }

impl Fid {
    pub fn enumerate_paths<P: AsRef<Path>>(
        iter: impl IntoIterator<Item = P>,
    ) -> impl Iterator<Item = (Fid, P)> {
        iter.into_iter()
            .enumerate()
            .map(|(n, p)| (Fid(n as u32), p))
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct FileSrc<X = ()> {
    id: Fid,
    path: PathBuf,
    data: X,
}

impl<X> FileSrc<X> {
    pub fn new<P: AsRef<Path>>(id: Fid, path: P, data: X) -> Self {
        Self {
            id,
            path: path.as_ref().to_path_buf(),
            data,
        }
    }

    pub fn map<F, Y>(self, mut f: F) -> FileSrc<Y>
    where
        F: FnMut(X) -> Y,
    {
        let FileSrc { id, path, data } = self;
        FileSrc {
            id,
            path,
            data: f(data),
        }
    }

    pub fn from_paths(
        paths: impl IntoIterator<Item = PathBuf>,
    ) -> impl Iterator<Item = FileSrc<()>> {
        paths.into_iter().enumerate().map(|(id, path)| FileSrc {
            id: Fid(id as u32),
            path,
            data: (),
        })
    }

    pub fn string_contents(&self) -> Result<String, std::io::Error> {
        std::fs::read_to_string(self.path.as_path())
    }

    pub fn load_string(self) -> Result<(FileSrc<String>, X), std::io::Error> {
        let string = self.string_contents()?;
        let FileSrc { id, path, data } = self;
        Ok((
            FileSrc {
                id,
                path,
                data: string,
            },
            data,
        ))
    }

    pub fn file_name(&self) -> Option<&str> {
        self.path.file_name().and_then(|n| n.to_str())
    }

    pub fn open_file(&self) -> Result<File, std::io::Error> {
        File::open(self.path.as_path())
    }

    pub fn get_id(&self) -> &Fid {
        &self.id
    }

    pub fn get_data(&self) -> &X {
        &self.data
    }

    pub fn get_data_mut(&mut self) -> &mut X {
        &mut self.data
    }
}

impl<X> FileSrc<X>
where
    X: AsRef<str>,
{
    pub fn content_str(&self) -> &str {
        self.data.as_ref()
    }
}

impl<X> AsRef<Path> for FileSrc<X> {
    fn as_ref(&self) -> &Path {
        self.path.as_path()
    }
}

#[derive(Clone, Debug)]
pub struct SrcTree<X> {
    files: Vec<FileSrc<X>>,
    queue: Deque<Fid>,
}

impl<X> SrcTree<X> {
    pub fn new() -> Self {
        Self {
            files: vec![],
            queue: Deque::new(),
        }
    }

    pub fn file_count(&self) -> usize {
        self.files.len()
    }

    pub fn add_file<P: AsRef<Path>>(
        &mut self,
        path: P,
        process: impl FnMut(String) -> X,
    ) -> std::io::Result<Fid> {
        let fid = Fid(self.files.len() as u32);
        let (filesrc, _) = FileSrc::new(fid, path, ()).load_string()?;
        self.files.push(filesrc.map(process));
        Ok(fid)
    }

    pub fn push_front(&mut self, fid: Fid) {
        self.queue.push_front(fid)
    }

    pub fn push_back(&mut self, fid: Fid) {
        self.queue.push_back(fid)
    }

    pub fn pop_front(&mut self) -> Option<Fid> {
        self.queue.pop_front()
    }

    pub fn pop_back(&mut self) -> Option<Fid> {
        self.queue.pop_back()
    }

    pub fn find<P>(&self, pred: P) -> Option<&FileSrc<X>>
    where
        P: FnMut(&&FileSrc<X>) -> bool,
    {
        self.files.iter().find(pred)
    }
}

impl<X> std::ops::Index<Fid> for SrcTree<X> {
    type Output = FileSrc<X>;

    fn index(&self, index: Fid) -> &Self::Output {
        &self.files[index.0 as usize]
    }
}

impl<X> std::ops::IndexMut<Fid> for SrcTree<X> {
    fn index_mut(&mut self, index: Fid) -> &mut Self::Output {
        &mut self.files[index.0 as usize]
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_file() {
        let filesrc = FileSrc::<()>::from_paths([PathBuf::from("../../language/prim.ws")])
            .next()
            .map(|filesrc| filesrc.load_string().unwrap().0);
        println!("{:?}", filesrc)
    }
}
