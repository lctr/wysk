{
  "fileTypes": [
    "wy"
  ],
  "keyEquivalent": "^~W",
  "name": "Wysk",
  "patterns": [
    {
      "include": "#comment_like"
    },
    {
      "include": "#numeric_literals"
    },
    {
      "include": "#string_literal"
    },
    {
      "include": "#char_literal"
    },
    {
      "match": "(?<!@|#)\\}~",
      "name": "invalid"
    },
    {
      "match": "(\\()\\s*(\\))",
      "name": "constant.language.unit.wysk",
      "captures": {
        "1": {
          "name": "punctuation.paren.wysk"
        },
        "2": {
          "name": "punctuation.paren.wysk"
        }
      }
    },
    {
      "match": "(\\()\\s*,[\\s,]*(\\))",
      "name": "support.constant.tuple.wysk",
      "captures": {
        "1": {
          "name": "punctuation.paren.wysk"
        },
        "2": {
          "name": "punctuation.paren.wysk"
        }
      }
    },
    {
      "match": "(\\[)\\s*(\\])",
      "name": "constant.language.empty-list.wysk",
      "captures": {
        "1": {
          "name": "punctuation.bracket.wysk"
        },
        "2": {
          "name": "punctuation.bracket.wysk"
        }
      }
    },
    {
      "begin": "(\\b(?<!')(module)|^(package))(\\b(?!'))",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.module.wysk"
        },
        "3": {
          "name": "keyword.other.signature.wysk"
        }
      },
      "end": "(?=\\b(?<!')where\\b(?!'))",
      "name": "meta.declaration.module.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#module_name"
        },
        {
          "include": "#module_exports"
        },
        {
          "match": "[a-z]+",
          "name": "invalid"
        }
      ]
    },
    {
      "include": "#ffi"
    },
    {
      "begin": "^(\\s*)(class)(\\b(?!'))",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.class.wysk"
        }
      },
      "end": "(?x) # Detect end of class declaration:\n         # 'where' keyword\n   (?=(?<!')\\b\\{\\b(?!'))\n         # Decreasing indentation\n   |(?=\\}|;)      # Explicit indentation\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n       \\1\\s+\\S    # - more indented, or\n     | \\s*        # - starts with whitespace, followed by:\n       (?: $      #   - the end of the line (i.e. empty line), or\n       |~\\{[^@]   #   - the start of a block comment, or\n       |~~[\\>|\\<|\\||\\:|~| |.]       #   - the start of a single-line comment.\n          (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                  # The double dash may not be followed by other operator characters\n                  # (then it would be an operator, not a comment)\n     )",
      "name": "meta.declaration.class.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#where"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "begin": "(?x)\n  ^(\\s*)(data|newtype)(?:\\s+(impl))?\\s+\n  # Keep consuming characters until:\n  ((?:(?!\n  # the equals symbol or the start of a single-line comment, or\n    (?:\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|~~[\\>|\\<|\\||\\:|~| |.])\n      (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the \"where\" or \"with\" keywords, or\n  | (?:\\b(?<!')(?:with)\\b(?!'))\n  # the start of a block comment.\n  | {-\n  #\n  ).)*)\n  (?=\\b(?<!'')with\\b(?!''))",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.$2.wysk"
        },
        "3": {
          "name": "keyword.other.impl.wysk"
        },
        "4": {
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      },
      "name": "meta.declaration.$2.generalized.wysk",
      "end": "(?x) # Detect end of data declaration:\n         # with clause\n   (?=(?<!')\\bwith\\b(?!'))\n         # Decreasing indentation\n   |(?=\\}|;)      # Explicit indentation\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n       \\1\\s+\\S    # - more indented, or\n     | \\s*        # - starts with whitespace, followed by:\n       (?: $      #   - the end of the line (i.e. empty line), or\n       |\\{-[^@]   #   - the start of a block comment, or\n       |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n          (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                  # The double dash may not be followed by other operator characters\n                  # (then it would be an operator, not a comment)\n     )\n",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "begin": "(?x)\n  (?<!')\\b(where)\n  \\s*(\\{)(?!-)",
          "end": "\\}",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.where.wysk"
            },
            "2": {
              "name": "punctuation.brace.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.brace.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#gadt_constructor"
            },
            {
              "match": ";",
              "name": "punctuation.semicolon.wysk"
            }
          ]
        },
        {
          "match": "\\b(?<!')(where)\\b(?!')",
          "name": "keyword.other.where.wysk"
        },
        {
          "include": "#with"
        },
        {
          "include": "#gadt_constructor"
        }
      ]
    },
    {
      "include": "#role_annotation"
    },
    {
      "name": "meta.declaration.pattern.type.wysk",
      "begin": "^(\\s*)(pattern)\\s+(.*?)\\s+(::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.pattern.wysk"
        },
        "3": {
          "patterns": [
            {
              "include": "#comma"
            },
            {
              "include": "#data_constructor"
            }
          ]
        },
        "4": {
          "name": "keyword.operator.double-colon.wysk"
        }
      },
      "end": "(?x) # Detect end of pattern type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| |.]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "patterns": [
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "name": "meta.declaration.pattern.wysk",
      "begin": "^\\s*(pattern)\\b(?!')",
      "captures": {
        "1": {
          "name": "keyword.other.pattern.wysk"
        }
      },
      "end": "(?x) # Detect end of pattern type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "patterns": [
        {
          "include": "$self"
        }
      ]
    },
    {
      "begin": "(?x)\n  # Data declaration\n  ^(\\s*)(data|newtype)(?:\\s+(family|impl))?\\s+\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol or the start of a single-line comment, or\n    (?:\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|~~[\\>|\\<|\\||\\:|~| ])\n      (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the \"where\" or \"with\" keywords, or\n  | (?:\\b(?<!')(?:with)\\b(?!'))\n  # the start of a block comment.\n  | ~{\n  #\n  ).)*)",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.$2.wysk"
        },
        "3": {
          "name": "keyword.other.$3.wysk"
        },
        "4": {
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      },
      "name": "meta.declaration.$2.algebraic.wysk",
      "end": "(?x) # Detect end of data declaration:\n     # Decreasing indentation\n   (?=\\}|;)      # Explicit indentation\n   |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n       \\1\\s+\\S    # - more indented, or\n     | \\s*        # - starts with whitespace, followed by:\n       (?: $      #   - the end of the line (i.e. empty line), or\n       |~\\{[^@]   #   - the start of a block comment, or\n       |~~[\\>|\\<|\\||\\:|~| |.]       #   - the start of a single-line comment.\n          (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                  # The double dash may not be followed by other operator characters\n                  # (then it would be an operator, not a comment)\n     )",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#with"
        },
        {
          "include": "#forall"
        },
        {
          "include": "#adt_constructor"
        },
        {
          "include": "#data_context"
        },
        {
          "include": "#record_decl"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "name": "meta.declaration.type.family.wysk",
      "begin": "(?x)\n  # Type family\n  ^(\\s*)(type)\\s+(family)\\b(?!')\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol or the start of a single-line comment, or\n    (?:\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|~~[\\>|\\<|\\||\\:|~| ])\n      (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the \"where\" keyword, or\n  | \\b(?<!')where\\b(?!')\n  # the start of a block comment.\n  | ~{\n  #\n  ).)*)",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.type.wysk"
        },
        "3": {
          "name": "keyword.other.family.wysk"
        },
        "4": {
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#where"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      },
      "end": "(?x) # Detect end of type family by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#where"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "name": "meta.declaration.type.wysk",
      "begin": "(?x)\n  # Type declaration\n  ^(\\s*)(type)(?:\\s+(impl))?\\s+\n  # Keep consuming characters until:\n  (((?!\n  # the equals symbol, the start of a single-line comment, or a type signature\n    (?:\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n      (?:=|~~[\\>|\\<|\\||\\:|~| ]|::|∷)\n      (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol\n    )\n  # the start of a block comment.\n  | ~{\n  #\n  ).)*)",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.type.wysk"
        },
        "3": {
          "name": "keyword.other.impl.wysk"
        },
        "4": {
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      },
      "end": "(?x) # Detect end of type definition by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "patterns": [
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "begin": "^(\\s*)(impl)(\\b(?!'))",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.impl.wysk"
        }
      },
      "end": "(?x) # Detect end of impl declaration:\n  # 'where' keyword or opening curly brace\n  (?=\\b(?<!')(where|\\{)\\b(?!'))\n  # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "name": "meta.declaration.impl.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#where"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    {
      "begin": "^(\\s*)(import)(\\b(?!'))",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.import.wysk"
        }
      },
      "end": "(?x) # Detect end of import\n  # 'where' keyword\n  (?=\\b(?<!')(where)\\b(?!'))\n  # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "name": "meta.import.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#where"
        },
        {
          "match": "(qualified|hiding)",
          "captures": {
            "1": {
              "name": "keyword.other.$1.wysk"
            }
          }
        },
        {
          "include": "#module_name"
        },
        {
          "include": "#qualified_name"
        },
        {
          "include": "#module_exports"
        }
      ]
    },
    {
      "include": "#with"
    },
    {
      "include": "#layout_herald"
    },
    {
      "include": "#keyword"
    },
    {
      "match": "^\\s*(infix[lr]?)\\s+(.*)",
      "captures": {
        "1": {
          "name": "keyword.other.fixity.$1.wysk"
        },
        "2": {
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#integer_literals"
            },
            {
              "match": ":[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*",
              "name": "constant.other.operator.infix.wysk"
            },
            {
              "include": "#infix_op"
            }
          ]
        }
      },
      "name": "meta.fixity-declaration.wysk"
    },
    {
      "include": "#start_type_signature"
    },
    {
      "include": "#overloaded_label"
    },
    {
      "include": "#type_application"
    },
    {
      "include": "#reserved_symbol"
    },
    {
      "include": "#fun_decl"
    },
    {
      "include": "#qualifier"
    },
    {
      "match": ":[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*",
      "name": "constant.other.operator.infix.wysk"
    },
    {
      "include": "#data_constructor"
    },
    {
      "include": "#prefix_op"
    },
    {
      "include": "#infix_op"
    },
    {
      "begin": "(\\()(#)\\s",
      "end": "(#)(\\))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.paren.wysk"
        },
        "2": {
          "name": "keyword.operator.hash.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.hash.wysk"
        },
        "2": {
          "name": "punctuation.paren.wysk"
        }
      },
      "patterns": [
        {
          "include": "#comma"
        },
        {
          "include": "$self"
        }
      ]
    },
    {
      "begin": "(\\()",
      "end": "(\\))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.paren.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.paren.wysk"
        }
      },
      "patterns": [
        {
          "include": "#comma"
        },
        {
          "include": "$self"
        }
      ]
    },
    {
      "include": "#quasi_quote"
    },
    {
      "begin": "(\\[)",
      "end": "(\\])",
      "beginCaptures": {
        "1": {
          "name": "punctuation.bracket.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.bracket.wysk"
        }
      },
      "patterns": [
        {
          "include": "#comma"
        },
        {
          "include": "$self"
        }
      ]
    },
    {
      "include": "#record"
    }
  ],
  "repository": {
    "block_comment": {
      "applyEndPatternLast": 1,
      "begin": "~\\{",
      "captures": {
        "0": {
          "name": "punctuation.definition.comment.wysk"
        }
      },
      "end": "\\}~",
      "name": "comment.block.wysk",
      "patterns": [
        {
          "include": "#block_comment"
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "begin": "^(\\s*)(~~[>|\\||\\:|\\<|~| ])",
          "beginCaptures": {
            "2": {
              "name": "punctuation.whitespace.comment.leading.wysk"
            }
          },
          "end": "(?=^(?!\\1~~[\\>|\\<|\\||\\:|~| ](?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])))",
          "name": "comment.block.documentation.wysk"
        },
        {
          "begin": "(^[ \\t]+)?(~~[\\:\\*])",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.wysk"
            }
          },
          "end": "\\n",
          "name": "comment.line.documentation.wysk"
        },
        {
          "applyEndPatternLast": 1,
          "begin": "~\\{[\\|\\:\\>\\^]",
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.wysk"
            }
          },
          "end": "-\\}",
          "name": "comment.block.documentation.wysk",
          "patterns": [
            {
              "include": "#block_comment"
            }
          ]
        },
        {
          "begin": "(^[ \\t]+)?(?=~~[\\>|\\<|\\||\\:|~| ](?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.wysk"
            }
          },
          "comment": "Operators may begin with '~~' as long as they are not entirely composed of '~' characters. This means comments can't be immediately followed by an allowable operator character.",
          "end": "(?!\\G)",
          "patterns": [
            {
              "begin": "~~",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.comment.wysk"
                }
              },
              "end": "\\n",
              "name": "comment.line.double-dash.wysk"
            }
          ]
        },
        {
          "include": "#block_comment"
        }
      ]
    },
    "comment_like": {
      "patterns": [
        {
          "include": "#comments"
        }
      ]
    },
    "where": {
      "patterns": [
        {
          "begin": "(?x)\n  (?<!')\\b(where)\n  \\s*(\\{)(?!-)",
          "end": "(\\})",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.where.wysk"
            },
            "2": {
              "name": "punctuation.brace.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.brace.wysk"
            }
          },
          "patterns": [
            {
              "include": "$self"
            },
            {
              "match": ";",
              "name": "punctuation.semicolon.wysk"
            }
          ]
        },
        {
          "match": "\\b(?<!')(where)\\b(?!')",
          "name": "keyword.other.where.wysk"
        }
      ]
    },
    "layout_herald": {
      "begin": "(?x)\n  (?:(?<!')\\b(?:(def|fn|class|impl|where|let|m?do)|(of))|(\\\\\\s*case))\n  \\s*(\\{)(?!-)",
      "end": "(\\})",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.$1.wysk"
        },
        "2": {
          "name": "keyword.control.of.wysk"
        },
        "3": {
          "name": "keyword.control.lambda-case.wysk"
        },
        "4": {
          "name": "punctuation.brace.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.brace.wysk"
        }
      },
      "patterns": [
        {
          "include": "$self"
        },
        {
          "match": ";",
          "name": "punctuation.semicolon.wysk"
        }
      ]
    },
    "keyword": {
      "match": "\\b(?<!')(?:(where|let|in)|(m?do|if|then|else|case|of))\\b(?!')",
      "captures": {
        "1": {
          "name": "keyword.other.$1.wysk"
        },
        "2": {
          "name": "keyword.control.$2.wysk"
        }
      }
    },
    "with": {
      "patterns": [
        {
          "begin": "^(\\s*)(with)\\s+(?:(via|newtype)\\s+)?",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.with.wysk"
            },
            "3": {
              "name": "keyword.other.with.strategy.$3.wysk"
            }
          },
          "end": "(?x) # Detect end of with statement\n  # Decreasing indentation\n   (?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )",
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "match": "(?<!')\\b(impl)\\b(?!')",
              "name": "keyword.other.impl.wysk"
            },
            {
              "match": "(?<!')\\b(via|newtype)\\b(?!')",
              "captures": {
                "1": {
                  "name": "keyword.other.with.strategy.$1.wysk"
                }
              }
            },
            {
              "include": "#type_signature"
            }
          ],
          "name": "meta.with.wysk"
        },
        {
          "begin": "(with)(?:\\s+(newtype))?\\s*(\\()",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.with.wysk"
            },
            "2": {
              "name": "keyword.other.with.strategy.$2.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            }
          },
          "end": "(\\))",
          "endCaptures": {
            "1": {
              "name": "punctuation.paren.wysk"
            }
          },
          "name": "meta.with.wysk",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "match": "(?x)\n  (with)(?:\\s+(newtype))?\\s+\n    ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n    (\\s+(via)\\s+(.*)$)?\n",
          "captures": {
            "1": {
              "name": "keyword.other.with.wysk"
            },
            "2": {
              "name": "keyword.other.with.strategy.$2.wysk"
            },
            "3": {
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            "5": {
              "name": "keyword.other.with.strategy.via.wysk"
            },
            "6": {
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            }
          },
          "name": "meta.with.wysk"
        },
        {
          "match": "(?<!')\\b(via)\\b(?!')",
          "name": "keyword.other.with.strategy.via.wysk"
        }
      ]
    },
    "prefix_op": {
      "patterns": [
        {
          "comment": "An operator cannot be composed entirely of '~' characters; instead, it should be matched as a comment.\n",
          "match": "(?x)\n  (\\()\\s*(?!(?:~~[\\>|\\<|\\||\\:|~| ]|\\.\\.)\\))(\\#+|[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+(?<!\\#))\\s*(\\))",
          "captures": {
            "1": {
              "name": "punctuation.paren.wysk"
            },
            "2": {
              "name": "entity.name.function.infix.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            }
          }
        }
      ]
    },
    "infix_op": {
      "patterns": [
        {
          "match": "(?x)\n  ((?:(?<!'')('')?[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*\\.)*)\n    (\\#+|[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+(?<!\\#))",
          "comment": "In case this regex seems overly general, note that Wysk permits the definition of new operators which can be nearly any string of punctuation characters, such as $%^&*.\n",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "entity.name.namespace.wysk"
            },
            "3": {
              "name": "keyword.operator.infix.wysk"
            }
          }
        },
        {
          "match": "(`)((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*\\.)*)([\\p{Ll}\\p{Lu}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'']*)(`)",
          "captures": {
            "1": {
              "name": "punctuation.backtick.wysk"
            },
            "2": {
              "name": "entity.name.namespace.wysk"
            },
            "3": {
              "patterns": [
                {
                  "include": "#data_constructor"
                }
              ]
            },
            "4": {
              "name": "punctuation.backtick.wysk"
            }
          },
          "comment": "In case this regex seems unusual for an infix operator, note that Wysk\nallows any ordinary function application (elem 4 [1..10]) to be rewritten\nas an infix expression (4 `elem` [1..10]).\n",
          "name": "keyword.operator.function.infix.wysk"
        }
      ]
    },
    "qualified_name": {
      "begin": "\\|",
      "end": "\\|",
      "patterns": {
        "captures": {
          "1": {
            "name": "entity.name.namespace.wysk"
          }
        }
      }
    },
    "module_exports": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.paren.wysk"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.paren.wysk"
        }
      },
      "applyEndPatternLast": 1,
      "name": "meta.declaration.exports.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "match": "\\b(?<!')(module)\\b(?!')",
          "captures": {
            "1": {
              "name": "keyword.other.module.wysk"
            }
          }
        },
        {
          "include": "#comma"
        },
        {
          "include": "#export_constructs"
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.brace.wysk"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.brace.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#record_wildcard"
            },
            {
              "match": "(\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))",
              "name": "constant.other.operator.prefix.wysk"
            },
            {
              "include": "#export_constructs"
            },
            {
              "include": "#comma"
            }
          ]
        }
      ]
    },
    "export_constructs": {
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "begin": "\\b(?<!')(pattern)\\b(?!')",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.pattern.wysk"
            }
          },
          "end": "(?x)\n   # Data constructor\n   ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n   # Prefix form of symbolic constructor\n   | (\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*(\\))",
          "endCaptures": {
            "1": {
              "name": "constant.other.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "constant.other.operator.prefix.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            }
          ]
        },
        {
          "begin": "\\b(?<!')(type)\\b(?!')",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.type.wysk"
            }
          },
          "end": "(?x)\n   # Type name\n   ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n   # Prefix form of type operator\n   | (\\()\\s*([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*(\\))",
          "endCaptures": {
            "1": {
              "name": "storage.type.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "storage.type.operator.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            }
          ]
        },
        {
          "include": "#record_wildcard"
        },
        {
          "include": "#reserved_symbol"
        },
        {
          "match": "(\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))",
          "name": "storage.type.operator.wysk"
        },
        {
          "match": "(?<!')\\b[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
          "name": "entity.name.function.wysk"
        },
        {
          "match": "(?<!')\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
          "name": "storage.type.wysk"
        },
        {
          "include": "#prefix_op"
        }
      ]
    },
    "comma": {
      "match": ",",
      "name": "punctuation.separator.comma.wysk"
    },
    "module_name": {
      "match": "(?<conid>[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(\\.\\g<conid>)?)",
      "name": "entity.name.namespace.wysk"
    },
    "data_context": {
      "match": "(?x)\n  (.*)\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n  (=>|⇒)\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n",
      "captures": {
        "1": {
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#forall"
            },
            {
              "begin": "(?='?\\()",
              "end": "(?=\\))",
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            {
              "begin": "(?='?\\[)",
              "end": "(?=\\])",
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            {
              "match": "(?x)\n  (\\S*)\\s*\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n  (::|∷|=)\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
              "captures": {
                "1": {
                  "patterns": [
                    {
                      "include": "#comment_like"
                    },
                    {
                      "include": "#forall"
                    },
                    {
                      "include": "#record_decl_field"
                    }
                  ]
                },
                "2": {
                  "patterns": [
                    {
                      "include": "#reserved_symbol"
                    }
                  ]
                },
                "3": {
                  "patterns": [
                    {
                      "include": "#type_signature"
                    }
                  ]
                }
              }
            },
            {
              "include": "#type_signature"
            }
          ]
        },
        "2": {
          "name": "keyword.operator.big-arrow.wysk"
        }
      }
    },
    "data_constructor": {
      "patterns": [
        {
          "match": "\\b(?<!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*(?![\\.'\\w])",
          "name": "constant.other.wysk"
        },
        {
          "match": "(\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))",
          "name": "constant.other.operator.wysk"
        }
      ]
    },
    "qualifier": {
      "match": "\\b(?<!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.",
      "name": "entity.name.namespace.wysk"
    },
    "record_decl": {
      "begin": "({)(?!-)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.brace.wysk"
        }
      },
      "end": "(?<!-)(})",
      "endCaptures": {
        "1": {
          "name": "punctuation.brace.wysk"
        }
      },
      "name": "meta.record.definition.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#record_decl_field"
        }
      ]
    },
    "record": {
      "begin": "({)(?!-)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.brace.wysk"
        }
      },
      "end": "(?<!-)(})",
      "endCaptures": {
        "1": {
          "name": "punctuation.brace.wysk"
        }
      },
      "name": "meta.record.wysk",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#record_field"
        }
      ]
    },
    "record_decl_field": {
      "begin": "(?x)\n  (?:([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n    |(\\()\\s*([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*(\\))\n  )\n",
      "end": "(,)|(?=})",
      "beginCaptures": {
        "1": {
          "name": "variable.other.member.definition.wysk"
        },
        "2": {
          "name": "punctuation.paren.wysk"
        },
        "3": {
          "name": "variable.other.member.definition.wysk"
        },
        "4": {
          "name": "punctuation.paren.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.comma.wysk"
        }
      },
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#comma"
        },
        {
          "include": "#double_colon"
        },
        {
          "include": "#type_signature"
        },
        {
          "include": "#record_decl_field"
        }
      ]
    },
    "record_wildcard": {
      "match": "(?x)\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n  (\\.\\.)\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
      "captures": {
        "1": {
          "name": "variable.other.member.wildcard.wysk"
        }
      }
    },
    "record_field": {
      "patterns": [
        {
          "begin": "(?x)\n  (?:([\\p{Ll}\\p{Lu}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\.']*)\n    |(\\()\\s*([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*(\\))\n  )\n",
          "end": "(,)|(?=})",
          "beginCaptures": {
            "1": {
              "name": "variable.other.member.wysk",
              "patterns": [
                {
                  "include": "#qualifier"
                }
              ]
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "variable.other.member.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.comma.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#comma"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "include": "#record_wildcard"
        }
      ]
    },
    "role_annotation": {
      "patterns": [
        {
          "begin": "^(\\s*)(type)\\s+(role)\\b(?!')",
          "beginCaptures": {
            "2": {
              "name": "keyword.other.type.wysk"
            },
            "3": {
              "name": "keyword.other.role.wysk"
            }
          },
          "end": "(?x) # Detect end of block by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |\\{-[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )",
          "name": "meta.role-annotation.wysk",
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#type_constructor"
            },
            {
              "match": "\\b(?<!')(nominal|representational|phantom)\\b(?!')",
              "captures": {
                "1": {
                  "name": "keyword.other.role.$1.wysk"
                }
              }
            }
          ]
        }
      ]
    },
    "fun_decl": {
      "begin": "(?x)^(\\s*)(fn|def)\\s+\n  (?<fn>\n    (?:\n      [\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\#*\n    | \\(\\s*\n        (?!~~[\\>|\\<|\\||\\:|~| ]\\))\n        [\\p{S}\\p{P}&&[^(),:;\\[\\]`{}_\"']]\n        [\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*\n      \\s*\\)\n    )\n    (?:\\s*,\\s*\\g<fn>)?\n  )\n  \\s*(?<![\\p{S}\\p{P}&&[^\\),;\\]`}_\"']])(::|∷)(?![\\p{S}\\p{P}&&[^\\(,;\\[`{_\"']])\n",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.$2.wysk"
        },
        "3": {
          "name": "entity.name.function.wysk",
          "patterns": [
            {
              "include": "#reserved_symbol"
            },
            {
              "include": "#prefix_op"
            }
          ]
        },
        "4": {
          "name": "keyword.operator.double-colon.wysk"
        }
      },
      "name": "meta.function.type-declaration.wysk",
      "patterns": [
        {
          "include": "#type_signature"
        }
      ],
      "end": "(?x)\n  # End of type annotation:\n    # To the left of a reserved symbolic keyword such as = or <-\n  (?=\n      # non-symbolic character\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n      # symbolic keyword except (->)\n      ((<-|←)|(=)|(-<|↢)|(-<<|⤛))\n      # non-symbolic character\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n  )\n  # Decreasing indentation:\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n"
    },
    "adt_constructor": {
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "begin": "(?x)\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n  (?:(=)|(\\|))\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.eq.wysk"
            },
            "2": {
              "name": "keyword.operator.pipe.wysk"
            }
          },
          "end": "(?x)\n  (?: # Infix data constructor\n    # First argument\n    (?:\n    # Simple type\n      (?<!')\\b((?:[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\.])+)\n    # Type inside balanced parentheses\n    | ('? # Optional promotion tick\n        (?<paren>\n          \\(          # Opening parenthesis\n          (?:\n            [^\\(\\)]*  # Match non-parentheses\n          | \\g<paren> # or recurse into further depth\n          )*\n          \\)          # Closing parenthesis\n        )\n      )\n    # Type inside balanced brackets\n    | ('? # Optional promotion tick\n        (?<brac>\n          \\[          # Opening bracket\n          (?:\n            [^\\[\\]]*  # Match non-brackets\n          | \\g<brac>  # or recurse into further depth\n          )*\n          \\]          # Closing bracket\n        )\n      )\n    )\n    # Then either\n    \\s*\n      # - a symbolic infix constructor, or\n    (?:(?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\n      # - an alphabetic infix constructor\n    | (`)([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)(`)\n    )\n  ) # Otherwise, prefix data constructor, either:\n  | # - an alphabetic data constructor e.g. \"Cons_123\"\n    (?:(?<!')\\b([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*))\n  | # - a symbolic (prefix) data constructor\n    (\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))\n  | # Otherwise, try to fail early to avoid excessive backtracking (https://github.com/JustusAdam/language-haskell/issues/161)\n      # Fail when detecting a lowercase identifier and then something not starting with a tick or colon\n      (?=\\b(?<!')(?!(?:forall|with)\\s)[\\p{Ll}_]\\S+\\s+[^`:])\n      # Fail when seeing another equal signs or pipe symbol\n     |(?=\n        (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]) # non-symbol\n        (?:=|\\|)\n        (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])  # non-symbol\n      )",
          "endCaptures": {
            "1": {
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            "2": {
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            "4": {
              "patterns": [
                {
                  "include": "#type_signature"
                }
              ]
            },
            "6": {
              "name": "constant.other.operator.infix.wysk"
            },
            "7": {
              "name": "punctuation.backtick.wysk"
            },
            "8": {
              "name": "constant.other.infix.wysk"
            },
            "9": {
              "name": "punctuation.backtick.wysk"
            },
            "10": {
              "name": "constant.other.wysk"
            },
            "11": {
              "name": "punctuation.paren.wysk"
            },
            "12": {
              "name": "constant.other.operator.prefix.wysk"
            },
            "13": {
              "name": "punctuation.paren.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#with"
            },
            {
              "include": "#record_decl"
            },
            {
              "include": "#forall"
            },
            {
              "include": "#data_context"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "gadt_constructor": {
      "patterns": [
        {
          "begin": "(?x)\n   ^(\\s*)\n      (?:\n        (\\b(?<!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n      |(\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))\n      )",
          "beginCaptures": {
            "2": {
              "name": "constant.other.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            },
            "4": {
              "name": "constant.other.operator.prefix.wysk"
            },
            "5": {
              "name": "punctuation.paren.wysk"
            }
          },
          "end": "(?x)\n  # GADT constructor ends\n  (?=\\b(?<!'')with\\b(?!'))\n        # Decreasing indentation\n  |(?=\\}|;)      # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#with"
            },
            {
              "include": "#double_colon"
            },
            {
              "include": "#record_decl"
            },
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(?x)\n  (\\b(?<!')[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}]*) # named constructor\n |(\\()\\s*(:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]*)\\s*(\\))    # prefix operator",
          "beginCaptures": {
            "1": {
              "name": "constant.other.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "constant.other.operator.prefix.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          },
          "end": "(?=;|\\}|$)",
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "include": "#with"
            },
            {
              "include": "#double_colon"
            },
            {
              "include": "#record_decl"
            },
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "type_application": {
      "patterns": [
        {
          "begin": "(?<=[\\s,;\\[\\]{}\"])(@)(')?(\\()",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.prefix.at.wysk"
            },
            "2": {
              "name": "keyword.operator.promotion.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.paren.wysk"
            }
          },
          "name": "meta.type-application.wysk",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(?<=[\\s,;\\[\\]{}\"])(@)(')?(\\[)",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.prefix.at.wysk"
            },
            "2": {
              "name": "keyword.operator.promotion.wysk"
            },
            "3": {
              "name": "punctuation.bracket.wysk"
            }
          },
          "end": "\\]",
          "name": "meta.type-application.wysk",
          "endCaptures": {
            "0": {
              "name": "punctuation.bracket.wysk"
            }
          },
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(?<=[\\s,;\\[\\]{}\"])(@)(?=\\\")",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.prefix.at.wysk"
            }
          },
          "end": "(?<=\\\")",
          "name": "meta.type-application.wysk",
          "patterns": [
            {
              "include": "#string_literal"
            }
          ]
        },
        {
          "begin": "(?<=[\\s,;\\[\\]{}\"])(@)(?=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.prefix.at.wysk"
            }
          },
          "end": "(?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])",
          "name": "meta.type-application.wysk",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "type_signature": {
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "match": "(')?(\\()\\s*(\\))",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            }
          },
          "name": "support.constant.unit.wysk"
        },
        {
          "match": "(\\()(#)\\s*(#)(\\))",
          "name": "support.constant.unit.unboxed.wysk",
          "captures": {
            "1": {
              "name": "punctuation.paren.wysk"
            },
            "2": {
              "name": "keyword.operator.hash.wysk"
            },
            "3": {
              "name": "keyword.operator.hash.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          }
        },
        {
          "match": "(')?(\\()\\s*,[\\s,]*(\\))",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "punctuation.paren.wysk"
            }
          },
          "name": "support.constant.tuple.wysk"
        },
        {
          "match": "(\\()(#)\\s*(#)(\\))",
          "name": "support.constant.unit.unboxed.wysk",
          "captures": {
            "1": {
              "name": "punctuation.paren.wysk"
            },
            "2": {
              "name": "keyword.operator.hash.wysk"
            },
            "3": {
              "name": "keyword.operator.hash.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          }
        },
        {
          "match": "(\\()(#)\\s*,[\\s,]*(#)(\\))",
          "captures": {
            "1": {
              "name": "punctuation.paren.wysk"
            },
            "2": {
              "name": "keyword.operator.hash.wysk"
            },
            "3": {
              "name": "keyword.operator.hash.wysk"
            },
            "4": {
              "name": "punctuation.paren.wysk"
            }
          },
          "name": "support.constant.tuple.unboxed.wysk"
        },
        {
          "match": "(')?(\\[)\\s*(\\])",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.bracket.wysk"
            },
            "3": {
              "name": "punctuation.bracket.wysk"
            }
          },
          "name": "support.constant.empty-list.wysk"
        },
        {
          "include": "#integer_literals"
        },
        {
          "match": "(::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])",
          "name": "keyword.operator.double-colon.wysk"
        },
        {
          "include": "#forall"
        },
        {
          "match": "=>|⇒",
          "name": "keyword.operator.big-arrow.wysk"
        },
        {
          "include": "#string_literal"
        },
        {
          "match": "'[^']'",
          "name": "invalid"
        },
        {
          "include": "#type_application"
        },
        {
          "include": "#reserved_symbol"
        },
        {
          "include": "#type_operator"
        },
        {
          "include": "#type_constructor"
        },
        {
          "begin": "(\\()(#)",
          "end": "(#)(\\))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.paren.wysk"
            },
            "2": {
              "name": "keyword.operator.hash.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.operator.hash.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comma"
            },
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(')?(\\()",
          "end": "(\\))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.paren.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comma"
            },
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(')?(\\[)",
          "end": "(\\])",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.bracket.wysk"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.bracket.wysk"
            }
          },
          "patterns": [
            {
              "include": "#comma"
            },
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "include": "#type_variable"
        }
      ]
    },
    "double_colon": {
      "match": "\\s*(::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\\s*",
      "captures": {
        "1": {
          "name": "keyword.operator.double-colon.wysk"
        }
      }
    },
    "start_type_signature": {
      "patterns": [
        {
          "begin": "^(\\s*)(::|∷)(?![\\p{S}\\p{P}&&[^\\(,;\\[`{_\"']])\\s*",
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.double-colon.wysk"
            }
          },
          "end": "(?x)\n  # End type annotation when seeing one of:\n  (?=\n    \\#?\\)                             # closing parenthesis\n    |\\]                               # closing bracket\n    |,                                # comma\n    |(?<!')\\b(in|then|else|of)\\b(?!') # keyword\n    |                                 # symbolic keyword except (->)\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n      (?:\n         (\\\\|λ)\n        |(<-|←)\n        |(=)\n        |(-<|↢)\n        |(-<<|⤛)\n      )\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n    |(\\#|@)-\\}                             # End of annotation block (LiquidWysk or pragma)\n    # Decreasing indentation:\n    | (?=\\}|;)     # Explicit indentation\n    |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n        \\1\\s*\\S    # - equally indented, or\n      | \\s*        # - starts with whitespace, followed by:\n        (?: $      #   - the end of the line (i.e. empty line), or\n        |~\\{[^@]   #   - the start of a block comment, or\n        |~~[\\>|\\<|\\||\\:|~| ]   #  - the start of a single-line comment.\n           (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                   # The double dash may not be followed by other operator characters\n                   # (then it would be an operator, not a comment)\n      )\n  )",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ],
          "name": "meta.type-declaration.wysk"
        },
        {
          "begin": "(?<![\\p{S}\\p{P}&&[^\\(,;\\[`{_\"']])(::|∷)(?![\\p{S}\\p{P}&&[^\\(,;\\[`{_\"']])",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.double-colon.wysk"
            }
          },
          "end": "(?x)\n  # End type annotation when seeing one of:\n  (?=\n    \\#?\\)                             # closing parenthesis\n    |\\]                               # closing bracket\n    |,                                # comma\n    |\\b(?<!')(in|then|else|of)\\b(?!') # keyword\n    |(\\#|@)-\\}                        # End of annotation block (LiquidWysk or pragma)\n    |                                 # symbolic keyword except (->)\n      (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']])\n      (?:\n         (\\\\|λ)\n        |(<-|←)\n        |(=)\n        |(-<|↢)\n        |(-<<|⤛)\n      )\n      ([(),;\\[\\]`{}_\"']|[^\\p{S}\\p{P}])\n    # Indentation\n    |(?=\\}|;)      # Explicit indentation\n    |$             # End of line\n  )",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        }
      ]
    },
    "type_variable": {
      "match": "\\b(?<!')(?!(?:forall|with)\\b(?!'))[\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*",
      "name": "variable.other.generic-type.wysk"
    },
    "type_constructor": {
      "patterns": [
        {
          "match": "(?x)\n  # Optional promotion tick\n    (')?\n  # Optional qualified name\n    ((?:\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type constructor proper\n    (\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "entity.name.namespace.wysk"
            },
            "3": {
              "name": "storage.type.wysk"
            }
          }
        },
        {
          "match": "(?x)\n  # Optional promotion tick\n    (')?\n  # Opening parenthesis\n    (\\()\\s*\n  # Optional qualified name\n    ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type operator proper\n    ([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\n  # Closing parenthesis\n    \\s*(\\))",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.paren.wysk"
            },
            "3": {
              "name": "entity.name.namespace.wysk"
            },
            "4": {
              "name": "storage.type.operator.wysk"
            },
            "5": {
              "name": "punctuation.paren.wysk"
            }
          }
        }
      ]
    },
    "overloaded_label": {
      "patterns": [
        {
          "match": "(?x)\n  (?<![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}&&[^(,;\\[`{]]) # Disallow closing characters\n  (\\#)\n    (?:\n    # String\n    (\"(?:\\\\\"|[^\"])*\")\n    # Sequence of allowed label identifiers\n    |[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\.]+\n    )",
          "captures": {
            "1": {
              "name": "keyword.operator.prefix.hash.wysk"
            },
            "2": {
              "patterns": [
                {
                  "include": "#string_literal"
                }
              ]
            }
          },
          "name": "entity.name.label.wysk"
        }
      ]
    },
    "reserved_symbol": {
      "patterns": [
        {
          "match": "(?x)\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"'']])\n  (?:\n     (\\.\\.)\n    |(:)\n    |(=)\n    |(\\\\)     # λ not reserved as it is a letter\n    |(\\|)\n    |(<-|←)\n    |(->|→)\n    |(-<|↢)\n    |(-<<|⤛)\n    |(>-|⤚)\n    |(>>-|⤜)\n  )\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"'']])",
          "captures": {
            "1": {
              "name": "keyword.operator.double-dot.wysk"
            },
            "2": {
              "name": "keyword.operator.colon.wysk"
            },
            "3": {
              "name": "keyword.operator.eq.wysk"
            },
            "4": {
              "name": "keyword.operator.lambda.wysk"
            },
            "5": {
              "name": "keyword.operator.pipe.wysk"
            },
            "6": {
              "name": "keyword.operator.arrow.left.wysk"
            },
            "7": {
              "name": "keyword.operator.arrow.wysk"
            },
            "8": {
              "name": "keyword.operator.arrow.left.tail.wysk"
            },
            "9": {
              "name": "keyword.operator.arrow.left.tail.double.wysk"
            },
            "10": {
              "name": "keyword.operator.arrow.tail.wysk"
            },
            "11": {
              "name": "keyword.operator.arrow.tail.double.wysk"
            }
          }
        },
        {
          "match": "(?x)\n  (?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}&&[^\\#,;\\[`{]]) # Require closing characters\n  (\\#+)\n  (?![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}&&[^),;\\]`}]])   # Disallow opening character",
          "captures": {
            "1": {
              "name": "keyword.operator.postfix.hash.wysk"
            }
          }
        },
        {
          "match": "(?x)\n  (?<=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\)\\}\\]]) # Require closing characters\n  (@)\n  (?=[\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'\\(\\[\\{]) # Require opening character",
          "captures": {
            "1": {
              "name": "keyword.operator.infix.tight.at.wysk"
            }
          }
        },
        {
          "match": "(?x)\n  (?<![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\\p{S}\\p{P}&&[^(,;\\[`{]])  # Disallow closing characters\n  (?:(~)|(!)|(-)|(\\$\\$)|(\\$)|(%))\n  (?=[\\p{Ll}_'\\p{Lu}\\p{Lt}\\p{Nd}\\(\\{\\[]) # Require opening character (non operator symbol)",
          "captures": {
            "1": {
              "name": "keyword.operator.prefix.tilde.wysk"
            },
            "2": {
              "name": "keyword.operator.prefix.bang.wysk"
            },
            "3": {
              "name": "keyword.operator.prefix.minus.wysk"
            },
            "4": {
              "name": "keyword.operator.prefix.double-dollar.wysk"
            },
            "5": {
              "name": "keyword.operator.prefix.dollar.wysk"
            },
            "6": {
              "name": "keyword.operator.prefix.modifier.wysk"
            }
          }
        }
      ]
    },
    "type_operator": {
      "patterns": [
        {
          "match": "(?x)\n  # Optional promotion tick\n    (?:(?<!')('))?\n  # Optional qualified name\n    ((?:\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type operator proper\n    (?![#@]?-})(\\#+|[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+(?<!\\#))\n    #((?:[\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']&&[^#@]]|[@#](?!-}))+)",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "entity.name.namespace.wysk"
            },
            "3": {
              "name": "storage.type.operator.infix.wysk"
            }
          }
        },
        {
          "match": "(?x)\n  # Optional promotion tick\n    (')?\n  # Opening backtick\n    (\\`)\n  # Optional qualified name\n    ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*)\n  # Type constructor proper\n    ([\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\n  # Closing backtick\n    (`)",
          "captures": {
            "1": {
              "name": "keyword.operator.promotion.wysk"
            },
            "2": {
              "name": "punctuation.backtick.wysk"
            },
            "3": {
              "name": "entity.name.namespace.wysk"
            },
            "4": {
              "name": "storage.type.infix.wysk"
            },
            "5": {
              "name": "punctuation.backtick.wysk"
            }
          }
        }
      ]
    },
    "forall": {
      "begin": "(?x)\n  # Alphabetic forall\n  (?:\n  \\b(?<!')\n  (forall)\n  \\b(?!')\n  )\n  |\n  # Symbolic forall\n  (?:\n  # Not preceded by a symbol except reserved symbols\n  (?<![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"'']])\n  (∀)\n  # Not followed by a symbol except reserved symbols\n  (?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"'']])\n  )",
      "end": "(\\.)|(->|→)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.forall.wysk"
        },
        "2": {
          "name": "keyword.other.forall.wysk"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.period.wysk"
        },
        "2": {
          "name": "keyword.operator.arrow.wysk"
        }
      },
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "include": "#type_variable"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    "string_literal": {
      "begin": "\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.wysk"
        }
      },
      "end": "\"",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.wysk"
        }
      },
      "name": "string.quoted.double.wysk",
      "patterns": [
        {
          "match": "\\\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\\"'\\&])",
          "name": "constant.character.escape.wysk"
        },
        {
          "match": "\\\\o[0-7]+|\\\\x[0-9A-Fa-f]+|\\\\[0-9]+",
          "name": "constant.character.escape.octal.wysk"
        },
        {
          "match": "\\\\\\^[A-Z@\\[\\]\\\\\\^_]",
          "name": "constant.character.escape.control.wysk"
        },
        {
          "begin": "\\\\\\s",
          "beginCaptures": {
            "0": {
              "name": "constant.character.escape.begin.wysk"
            }
          },
          "end": "\\\\",
          "endCaptures": {
            "0": {
              "name": "constant.character.escape.end.wysk"
            }
          },
          "patterns": [
            {
              "match": "\\S+",
              "name": "invalid.illegal.character-not-allowed-here.wysk"
            }
          ]
        }
      ]
    },
    "char_literal": {
      "captures": {
        "1": {
          "name": "punctuation.definition.string.begin.wysk"
        },
        "2": {
          "name": "constant.character.escape.wysk"
        },
        "3": {
          "name": "constant.character.escape.octal.wysk"
        },
        "4": {
          "name": "constant.character.escape.hexadecimal.wysk"
        },
        "5": {
          "name": "constant.character.escape.control.wysk"
        },
        "6": {
          "name": "punctuation.definition.string.end.wysk"
        }
      },
      "match": "(?x)\n  (?<![\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}'])\n  (')\n  (?:\n    [\\ -\\[\\]-~]                         # Basic Char\n  | (\\\\(?:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE\n       |DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS\n       |US|SP|DEL|[abfnrtv\\\\\\\"'\\\\&]))   # Escapes\n  | (\\\\o[0-7]+)                         # Octal Escapes\n  | (\\\\x[0-9A-Fa-f]+)                   # Hexadecimal Escapes\n  | (\\\\\\^[A-Z@\\[\\]\\\\\\^_])                 # Control Chars\n  )\n  (')\n",
      "name": "string.quoted.single.wysk"
    },
    "float_literals": {
      "comment": "Floats are decimal or hexadecimal",
      "match": "(?x)\n  \\b(?<!')\n  (?:  # Decimal\n    ([0-9][_0-9]*\\.[0-9][_0-9]*(?:[eE][-+]?[0-9][_0-9]*)?\n    |[0-9][_0-9]*[eE][-+]?[0-9][_0-9]*\n    )\n  |    # Hexadecimal\n    (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*\\.[0-9a-fA-F][_0-9a-fA-F]*(?:[pP][-+]?[0-9][_0-9]*)?\n    |0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*[pP][-+]?[0-9][_0-9]*\n    )\n  )\\b(?!')",
      "captures": {
        "1": {
          "name": "constant.numeric.floating.decimal.wysk"
        },
        "2": {
          "name": "constant.numeric.floating.hexadecimal.wysk"
        }
      }
    },
    "integer_literals": {
      "match": "(?x)\n  \\b(?<!')\n  (?:\n    ([0-9][_0-9]*)                    # Decimal integer\n  | (0[xX]_*[0-9a-fA-F][_0-9a-fA-F]*) # Hexadecimal integer\n  | (0[oO]_*[0-7][_0-7]*)             # Octal integer\n  | (0[bB]_*[01][_01]*)               # Binary integer\n  )\n  \\b(?!')",
      "captures": {
        "1": {
          "name": "constant.numeric.integral.decimal.wysk"
        },
        "2": {
          "name": "constant.numeric.integral.hexadecimal.wysk"
        },
        "3": {
          "name": "constant.numeric.integral.octal.wysk"
        },
        "4": {
          "name": "constant.numeric.integral.binary.wysk"
        }
      }
    },
    "numeric_literals": {
      "patterns": [
        {
          "include": "#float_literals"
        },
        {
          "include": "#integer_literals"
        }
      ]
    },
    "ffi": {
      "begin": "^(\\s*)(extern)\\s+(import|export)\\s+",
      "beginCaptures": {
        "2": {
          "name": "keyword.other.extern.wysk"
        },
        "3": {
          "name": "keyword.other.$3.wysk"
        }
      },
      "name": "meta.$3.extern.wysk",
      "end": "(?x) # Detect end of FFI block by decreasing indentation:\n  (?=\\}|;)       # Explicit indentation\n  |^(?!          # Implicit indentation: end match on newline *unless* the new line is either:\n      \\1\\s+\\S    # - more indented, or\n    | \\s*        # - starts with whitespace, followed by:\n      (?: $      #   - the end of the line (i.e. empty line), or\n      |~\\{[^@]   #   - the start of a block comment, or\n      |~~[\\>|\\<|\\||\\:|~| ]       #   - the start of a single-line comment.\n         (?![\\p{S}\\p{P}&&[^(),;\\[\\]{}`_\"']]).*$) # non-symbol\n                 # The double dash may not be followed by other operator characters\n                 # (then it would be an operator, not a comment)\n    )\n",
      "patterns": [
        {
          "include": "#comment_like"
        },
        {
          "match": "\\b(?<!')(ccall|rustfn)\\s+",
          "captures": {
            "1": {
              "name": "keyword.other.calling-convention.$1.wysk"
            }
          }
        },
        {
          "begin": "(?=\")|(?=\\b(?<!')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))",
          "end": "(?=(::|∷)(?![\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]))",
          "patterns": [
            {
              "include": "#comment_like"
            },
            {
              "match": "(?x)\n  \\b(?<!')(safe|unsafe)\\b(?!')\n  \\s*\n  (\"(?:\\\\\"|[^\"])*\")?\n  \\s*\n  (?:\n    (?:\\b(?<!'')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))\n   |(?:\\(\\s*(?!~~[\\>|\\<|\\||\\:|~| ]\\))([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*\\))\n  )\n",
              "captures": {
                "1": {
                  "name": "keyword.other.safety.$1.wysk"
                },
                "2": {
                  "name": "entity.name.extern.wysk",
                  "patterns": [
                    {
                      "include": "#string_literal"
                    }
                  ]
                },
                "3": {
                  "name": "entity.name.function.wysk"
                },
                "4": {
                  "name": "entity.name.function.infix.wysk"
                }
              }
            },
            {
              "match": "(?x)\n  \\b(?<!')(safe|unsafe)\\b(?!')\n  \\s*\n  (\"(?:\\\\\"|[^\"])*\")?\n  \\s*$\n",
              "captures": {
                "1": {
                  "name": "keyword.other.safety.$1.wysk"
                },
                "2": {
                  "name": "entity.name.extern.wysk",
                  "patterns": [
                    {
                      "include": "#string_literal"
                    }
                  ]
                }
              }
            },
            {
              "match": "(?x)\n  \"(?:\\\\\"|[^\"])*\"",
              "captures": {
                "0": {
                  "name": "entity.name.extern.wysk",
                  "patterns": [
                    {
                      "include": "#string_literal"
                    }
                  ]
                }
              }
            },
            {
              "match": "(?x)\n   (?:\\b(?<!'')([\\p{Ll}_][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*)\\b(?!'))\n  |(?:(\\()\\s*(?!~~[\\>|\\<|\\||\\:|~| ]\\))([\\p{S}\\p{P}&&[^(),;\\[\\]`{}_\"']]+)\\s*(\\)))\n",
              "captures": {
                "1": {
                  "name": "entity.name.function.wysk"
                },
                "2": {
                  "name": "punctuation.paren.wysk"
                },
                "3": {
                  "name": "entity.name.function.infix.wysk"
                },
                "4": {
                  "name": "punctuation.paren.wysk"
                }
              }
            }
          ]
        },
        {
          "include": "#double_colon"
        },
        {
          "include": "#type_signature"
        }
      ]
    },
    "inline_phase": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.bracket.wysk"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.bracket.wysk"
        }
      },
      "name": "meta.inlining-phase.wysk",
      "patterns": [
        {
          "match": "~",
          "name": "punctuation.tilde.wysk"
        },
        {
          "include": "#integer_literals"
        },
        {
          "match": "\\w*",
          "name": "invalid"
        }
      ]
    },
    "quasi_quote": {
      "patterns": [
        {
          "begin": "(?x)\n  (\\[)\n  (e|d|p)?\n  (\\|(?:\\|(?!\\]))?)",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            },
            "2": {
              "name": "entity.name.quasi-quoter.wysk"
            },
            "3": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            }
          },
          "end": "\\3\\]",
          "endCaptures": {
            "0": {
              "name": "keyword.operator.quasi-quotation.end.wysk"
            }
          },
          "name": "meta.quasi-quotation.wysk",
          "patterns": [
            {
              "include": "$self"
            }
          ]
        },
        {
          "begin": "(?x)\n  (\\[)\n  (t)\n  (\\|(?:\\|(?!\\]))?)",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            },
            "2": {
              "name": "entity.name.quasi-quoter.wysk"
            },
            "3": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            }
          },
          "end": "\\3\\]",
          "endCaptures": {
            "0": {
              "name": "keyword.operator.quasi-quotation.end.wysk"
            }
          },
          "name": "meta.quasi-quotation.wysk",
          "patterns": [
            {
              "include": "#type_signature"
            }
          ]
        },
        {
          "begin": "(?x)\n  (\\[)\n  (?:(\\$\\$)|(\\$))?\n  (?!'\\|')                                             # Don't parse ['|'...] as a quasi quotation\n  ((?:[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}']*\\.)*) # Optional qualifier\n  ((?:[^\\s\\p{S}\\p{P}]|['_])*)                          # Quasi-quoter\n  (\\|)",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            },
            "2": {
              "name": "keyword.operator.prefix.double-dollar.wysk"
            },
            "3": {
              "name": "keyword.operator.prefix.dollar.wysk"
            },
            "4": {
              "name": "entity.name.namespace.wysk"
            },
            "5": {
              "name": "entity.name.quasi-quoter.wysk"
            },
            "6": {
              "name": "keyword.operator.quasi-quotation.begin.wysk"
            }
          },
          "end": "\\|\\]",
          "endCaptures": {
            "0": {
              "name": "keyword.operator.quasi-quotation.end.wysk"
            }
          },
          "name": "meta.quasi-quotation.wysk meta.embedded.block.$5"
        }
      ]
    }
  },
  "scopeName": "source.wysk"
}
