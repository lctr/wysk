use program::RawProgram;
use token::*;
use wy_common::either::Either;
use wy_lexer::*;
use wy_name::ident::{Ident, IdentKind};
use wy_sources::files::File;
use wy_syntax::{
    expr::RawExpression,
    tipo::{Signature, Type},
};

mod attr;
mod decl;
pub mod error;
mod expr;
pub mod fixity;
mod pat;
mod program;
pub mod stream;
mod ty;

use error::*;
use stream::{Parser, Streaming};

impl<'t> Parser<'t> {
    // TODO: add span information to emitted identifiers
    #[allow(unused)]
    pub(crate) fn bump_ident(&mut self, kind: IdentKind) -> Parsed<Spanned<Ident>> {
        self.peek()
            .and_then(|t| {
                t.spanned()
                    .map(|lex| lex.ident_symbol().and_then(|s| kind.maybe_ident(s)))
                    .transpose()
            })
            .map(|id| self.bumped(id))
            .ok_or_else(|| {
                self.expected(match kind {
                    IdentKind::Upper => LexKind::Upper,
                    IdentKind::Lower => LexKind::Lower,
                    IdentKind::Infix => LexKind::Infix,
                    IdentKind::Label => LexKind::Label,
                    IdentKind::Fresh => {
                        unreachable!("Fresh identifiers are not generated by the lexer")
                    }
                })
            })
    }

    #[inline]
    pub(crate) fn expect_upper(&mut self) -> Parsed<Ident> {
        // TODO: remove method `take_item` call when spanned idents
        // are accepted
        self.bump_ident(IdentKind::Upper).map(Spanned::take_item)
    }

    #[inline]
    pub(crate) fn expect_lower(&mut self) -> Parsed<Ident> {
        self.bump_ident(IdentKind::Lower).map(Spanned::take_item)
    }

    #[inline]
    pub(crate) fn expect_infix(&mut self) -> Parsed<Ident> {
        self.bump_ident(IdentKind::Infix).map(Spanned::take_item)
    }

    #[inline]
    #[allow(unused)]
    pub(crate) fn expect_label(&mut self) -> Parsed<Spanned<Ident>> {
        self.bump_ident(IdentKind::Label)
    }

    pub(crate) fn expect_ident(&mut self) -> Parsed<Ident> {
        self.peek()
            .and_then(Token::lift(Lexeme::mk_id(Ident::NAMES)))
            .map(|id| self.bumped(id))
            .ok_or_else(|| self.expected(LexKind::Identifier))
    }

    #[inline]
    pub(crate) fn expect_literal(&mut self) -> Parsed<Literal> {
        self.peek()
            .and_then(Token::lift(Lexeme::literal))
            .map(|lit| self.bumped(lit))
            .ok_or_else(|| self.expected(LexKind::Literal))
    }
}

pub fn parse_program(src: &str) -> Parsed<program::RawProgram> {
    Parser::from_str(src).parse_program()
}

/// Parsing the type portion of a type signature in an isolated context
pub fn parse_type_node(src: &str) -> Parsed<Type> {
    Parser::from_str(src).ty_node()
}

/// Parsing a type signature in an isolated context
pub fn parse_type_signature(src: &str) -> Parsed<Signature<Ident, Ident>> {
    Parser::from_str(src).ty_signature()
}

/// Parsing en expression in an isolated context
pub fn parse_expression(src: &str) -> Parsed<RawExpression> {
    Parser::from_str(src).expression()
}

pub fn parse_file(file: &File) -> Parsed<RawProgram> {
    Parser::new(file.source(), file.src_path().path()).parse_program()
}

pub fn parse_standalone<P: AsRef<std::path::Path>>(
    filepath: P,
) -> Result<program::RawProgram, Either<std::io::Error, ParseError>> {
    let path = filepath.as_ref();
    std::fs::read_to_string(path)
        .map_err(Either::Left)
        .and_then(|content| {
            Parser::new(content.as_str(), path)
                .parse_program()
                .map_err(Either::Right)
        })
}
